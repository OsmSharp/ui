//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 MapCSS.g 2013-02-23 16:22:02

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


 // part of mapcss;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
//[System.CLSCompliant(false)]
public partial class MapCSSParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ATTRIBUTE_SELECTOR", "CHAR", "CHILD_COMBINATOR", "CLASS_SELECTOR", "COLON", "CSS_IDENT", "DECLARATION", "DECLARATION_BLOCK", "DESCENDANT_COMBINATOR", "DIGIT", "DIV", "DQUOTED_STRING", "EBACKSLASH", "EDQUOTE", "ESQUOTE", "EVAL", "EVAL_CALL", "FUNCTION_CALL", "HEXCOLOR", "HEXDIGIT", "HWS", "IDENTS", "IMPORT", "INCREMENT", "INDEX", "INDEX_SELECTOR", "LAYER_ID_SELECTOR", "LBRACE", "LBRACKET", "LIST", "ML_COMMENT", "NCOMPONENT", "NEGATIVE_FLOAT", "NEGATIVE_INT", "NMCHAR", "NMSTART", "NONASCII", "NUMBER", "OP_AND", "OP_CONTAINS", "OP_DIV", "OP_ENDS_WITH", "OP_EQ", "OP_EXIST", "OP_GE", "OP_GT", "OP_LE", "OP_LT", "OP_MATCH", "OP_MINUS", "OP_MOD", "OP_MUL", "OP_NEGATE", "OP_NEQ", "OP_NOT", "OP_NOT_EXIST", "OP_OR", "OP_PLUS", "OP_STARTS_WITH", "OP_SUBSTRING", "OP_TRUTHY", "OSM_TAG", "P", "PARENT_COMBINATOR", "PERCENTAGE", "PIXELS", "POINTS", "POSITIVE_FLOAT", "POSITIVE_INT", "PREDICATE", "PSEUDO_CLASS_SELECTOR", "RANGE", "RBRACE", "RBRACKET", "REGEXP", "REGEX_CHAR", "REGEX_ESCAPE", "REGEX_START", "RGB", "RGBA", "ROLE", "ROLE_SELECTOR", "RULE", "SEMICOLON", "SIMPLE_SELECTOR", "SL_COMMENT", "SQUOTED_STRING", "STYLESHEET", "T", "TAGSEPARATOR", "TYPE_SELECTOR", "UNICODE", "URL", "URLCONTENT", "VALUE_FLOAT", "VALUE_INCREMENT", "VALUE_INT", "VALUE_KEYWORD", "VALUE_LIST", "VALUE_PERCENTAGE", "VALUE_PIXELS", "VALUE_POINTS", "VALUE_QUOTED", "VALUE_REGEXP", "VALUE_RGB", "VALUE_RGBA", "VALUE_URL", "WS", "X", "ZOOM_SELECTOR", "'!'", "'!.'", "'!:'", "'('", "')'", "','", "'-'", "'.'", "':!'", "'::'", "'?'"
	};
	public const int EOF=-1;
	public const int ATTRIBUTE_SELECTOR=4;
	public const int CHAR=5;
	public const int CHILD_COMBINATOR=6;
	public const int CLASS_SELECTOR=7;
	public const int COLON=8;
	public const int CSS_IDENT=9;
	public const int DECLARATION=10;
	public const int DECLARATION_BLOCK=11;
	public const int DESCENDANT_COMBINATOR=12;
	public const int DIGIT=13;
	public const int DIV=14;
	public const int DQUOTED_STRING=15;
	public const int EBACKSLASH=16;
	public const int EDQUOTE=17;
	public const int ESQUOTE=18;
	public const int EVAL=19;
	public const int EVAL_CALL=20;
	public const int FUNCTION_CALL=21;
	public const int HEXCOLOR=22;
	public const int HEXDIGIT=23;
	public const int HWS=24;
	public const int IDENTS=25;
	public const int IMPORT=26;
	public const int INCREMENT=27;
	public const int INDEX=28;
	public const int INDEX_SELECTOR=29;
	public const int LAYER_ID_SELECTOR=30;
	public const int LBRACE=31;
	public const int LBRACKET=32;
	public const int LIST=33;
	public const int ML_COMMENT=34;
	public const int NCOMPONENT=35;
	public const int NEGATIVE_FLOAT=36;
	public const int NEGATIVE_INT=37;
	public const int NMCHAR=38;
	public const int NMSTART=39;
	public const int NONASCII=40;
	public const int NUMBER=41;
	public const int OP_AND=42;
	public const int OP_CONTAINS=43;
	public const int OP_DIV=44;
	public const int OP_ENDS_WITH=45;
	public const int OP_EQ=46;
	public const int OP_EXIST=47;
	public const int OP_GE=48;
	public const int OP_GT=49;
	public const int OP_LE=50;
	public const int OP_LT=51;
	public const int OP_MATCH=52;
	public const int OP_MINUS=53;
	public const int OP_MOD=54;
	public const int OP_MUL=55;
	public const int OP_NEGATE=56;
	public const int OP_NEQ=57;
	public const int OP_NOT=58;
	public const int OP_NOT_EXIST=59;
	public const int OP_OR=60;
	public const int OP_PLUS=61;
	public const int OP_STARTS_WITH=62;
	public const int OP_SUBSTRING=63;
	public const int OP_TRUTHY=64;
	public const int OSM_TAG=65;
	public const int P=66;
	public const int PARENT_COMBINATOR=67;
	public const int PERCENTAGE=68;
	public const int PIXELS=69;
	public const int POINTS=70;
	public const int POSITIVE_FLOAT=71;
	public const int POSITIVE_INT=72;
	public const int PREDICATE=73;
	public const int PSEUDO_CLASS_SELECTOR=74;
	public const int RANGE=75;
	public const int RBRACE=76;
	public const int RBRACKET=77;
	public const int REGEXP=78;
	public const int REGEX_CHAR=79;
	public const int REGEX_ESCAPE=80;
	public const int REGEX_START=81;
	public const int RGB=82;
	public const int RGBA=83;
	public const int ROLE=84;
	public const int ROLE_SELECTOR=85;
	public const int RULE=86;
	public const int SEMICOLON=87;
	public const int SIMPLE_SELECTOR=88;
	public const int SL_COMMENT=89;
	public const int SQUOTED_STRING=90;
	public const int STYLESHEET=91;
	public const int T=92;
	public const int TAGSEPARATOR=93;
	public const int TYPE_SELECTOR=94;
	public const int UNICODE=95;
	public const int URL=96;
	public const int URLCONTENT=97;
	public const int VALUE_FLOAT=98;
	public const int VALUE_INCREMENT=99;
	public const int VALUE_INT=100;
	public const int VALUE_KEYWORD=101;
	public const int VALUE_LIST=102;
	public const int VALUE_PERCENTAGE=103;
	public const int VALUE_PIXELS=104;
	public const int VALUE_POINTS=105;
	public const int VALUE_QUOTED=106;
	public const int VALUE_REGEXP=107;
	public const int VALUE_RGB=108;
	public const int VALUE_RGBA=109;
	public const int VALUE_URL=110;
	public const int WS=111;
	public const int X=112;
	public const int ZOOM_SELECTOR=113;
	public const int T__114=114;
	public const int T__115=115;
	public const int T__116=116;
	public const int T__117=117;
	public const int T__118=118;
	public const int T__119=119;
	public const int T__120=120;
	public const int T__121=121;
	public const int T__122=122;
	public const int T__123=123;
	public const int T__124=124;

	public MapCSSParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public MapCSSParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return MapCSSParser.tokenNames; } }
	public override string GrammarFileName { get { return "MapCSS.g"; } }


		
	        internal static string _extractUrl(IToken URL110)
	        {
	            if (URL110 != null &&
	                URL110.Text != null &&
	                URL110.Text.Length > 0)
	            { // there is content!
	                if (URL110.Text.Substring(0, 4) != "url(")
	                { // there is support to be an url( definition here!
	                    throw new System.ArgumentOutOfRangeException("URL content incorect: {0}", URL110.Text);
	                }

	                return URL110.Text.Substring(5, URL110.Text.Length - 2 - 5);
	            }
	            return string.Empty;
	        }

	        /// <summary>
	        /// Gets the blue part of a token containing a color as a number 0-255.
	        /// </summary>
	        /// <param name="c"></param>
	        /// <returns></returns>
	        internal static string _blue(IToken c)
	        {
	            if (c.Text != null)
	            { // there is something to parse.
	                if(c.Text.Length == 7 &&
	                    c.Text[0] == '#')
	                { // should be a hex color.
	                    int color;
	                    string color_hex = "" + c.Text[5] + c.Text[6];
	                    if (!int.TryParse(color_hex,
	                        System.Globalization.NumberStyles.HexNumber,
	                        System.Globalization.CultureInfo.InvariantCulture, out color))
	                    { // parsing did not succeed. 
	                        // try again an let the exception go.
	                        int.Parse(color_hex,
	                            System.Globalization.NumberStyles.HexNumber,
	                            System.Globalization.CultureInfo.InvariantCulture);
	                    }

	                    // success!
	                    return (color).ToString();
                    }
                    else if (c.Text.Length == 4 &&
                        c.Text[0] == '#')
                    { // should be a hex color.
                        byte color;
                        string color_hex = "" + c.Text[3] + c.Text[3];
                        if (!byte.TryParse(color_hex,
                            System.Globalization.NumberStyles.HexNumber,
                            System.Globalization.CultureInfo.InvariantCulture, out color))
                        { // parsing did not succeed. 
                            // try again an let the exception go.
                            int.Parse(color_hex,
                                System.Globalization.NumberStyles.HexNumber,
                                System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // success!
                        return (color).ToString();
                    }
	            }
	            return string.Empty;
	        }

	        /// <summary>
	        /// Gets the green part of a token containing a color as a number 0-255.
	        /// </summary>
	        /// <param name="c"></param>
	        /// <returns></returns>
	        internal static string _green(IToken c)
	        {
	            if (c.Text != null)
	            { // there is something to parse.
	                if (c.Text.Length == 7 &&
	                    c.Text[0] == '#')
	                { // should be a hex color.
	                    byte color;
	                    string color_hex = "" + c.Text[3] + c.Text[4];
	                    if (!byte.TryParse(color_hex,
	                        System.Globalization.NumberStyles.HexNumber,
	                        System.Globalization.CultureInfo.InvariantCulture, out color))
	                    { // parsing did not succeed. 
	                        // try again an let the exception go.
	                        int.Parse(color_hex,
	                            System.Globalization.NumberStyles.HexNumber,
	                            System.Globalization.CultureInfo.InvariantCulture);
	                    }

	                    // success!
	                    return (color).ToString();
                    }
                    else if (c.Text.Length == 4 &&
                        c.Text[0] == '#')
                    { // should be a hex color.
                        byte color;
                        string color_hex = "" + c.Text[2] + c.Text[2];
                        if (!byte.TryParse(color_hex,
                            System.Globalization.NumberStyles.HexNumber,
                            System.Globalization.CultureInfo.InvariantCulture, out color))
                        { // parsing did not succeed. 
                            // try again an let the exception go.
                            int.Parse(color_hex,
                                System.Globalization.NumberStyles.HexNumber,
                                System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // success!
                        return (color).ToString();
                    }
	            }
	            return string.Empty;
	        }

	        /// <summary>
	        /// Gets the red part of a token containing a color as a number 0-255.
	        /// </summary>
	        /// <param name="c"></param>
	        /// <returns></returns>
	        internal static string _red(IToken c)
	        {
	            if (c.Text != null)
	            { // there is something to parse.
	                if (c.Text.Length == 7 &&
	                    c.Text[0] == '#')
	                { // should be a hex color.
	                    byte color;
	                    string color_hex = "" + c.Text[1] + c.Text[2];
	                    if (!byte.TryParse(color_hex, 
	                        System.Globalization.NumberStyles.HexNumber,
	                        System.Globalization.CultureInfo.InvariantCulture, out color))
	                    { // parsing did not succeed. 
	                        // try again an let the exception go.
	                        int.Parse(color_hex,
	                            System.Globalization.NumberStyles.HexNumber,
	                            System.Globalization.CultureInfo.InvariantCulture);
	                    }

	                    // success!
	                    return (color).ToString();
                    }
                    else if (c.Text.Length == 4 &&
                        c.Text[0] == '#')
                    { // should be a hex color.
                        byte color;
                        string color_hex = "" + c.Text[1] + c.Text[1];
                        if (!byte.TryParse(color_hex,
                            System.Globalization.NumberStyles.HexNumber,
                            System.Globalization.CultureInfo.InvariantCulture, out color))
                        { // parsing did not succeed. 
                            // try again an let the exception go.
                            int.Parse(color_hex,
                                System.Globalization.NumberStyles.HexNumber,
                                System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // success!
                        return (color).ToString();
                    }
	            }
	            return string.Empty;
	        }

	        /// <summary>
	        /// Get the higher zoom.
	        /// </summary>
	        /// <param name="v"></param>
	        /// <returns></returns>
	        internal static string _zoomUpper(IToken v)
	        {
	            if (v != null &&
	                v.Text != null)
	            { // there is content in the token.
	                if (v.Text[0] != 'z')
	                { // first character verified.
	                    string zoom_string = new string(v.Text.ToCharArray(),
	                        2, v.Text.Length - 2);
	                    string[] zooms = zoom_string.Split('-');
	                    if (zooms.Length == 1)
	                    { // there is just one zoom, return it as the lower zoom!
	                        return zooms[0];
	                    }
	                    else if (zooms.Length == 2)
	                    { // get just the lower zoom.
	                        int zoom;
	                        if (zooms[1] != null &&
	                            zooms[1].Length > 0)
	                        { // there is content!
	                            if (int.TryParse(zooms[1], out zoom))
	                            { // zoom value.
	                                return zooms[1];
	                            } // invalid zoom string.
	                            throw new System.ArgumentOutOfRangeException(string.Format("Zoom string {0} cannot be parsed!",
	                                v.Text));
	                        }
	                        return zooms[1];
	                    }
	                    else
	                    { // invalid zoom string.
	                        throw new System.ArgumentOutOfRangeException(string.Format("Zoom string {0} cannot be parsed!",
	                            v.Text));
	                    }
	                }
	            }
	            return string.Empty;
	        }

	        /// <summary>
	        /// Get the lower zoom.
	        /// </summary>
	        /// <param name="v"></param>
	        /// <returns></returns>
	        internal static string _zoomLower(IToken v)
	        {
	            if (v != null &&
	                v.Text != null)
	            { // there is content in the token.
	                if (v.Text[0] != 'z')
	                { // first character verified.
	                    string zoom_string = new string(v.Text.ToCharArray(),
	                        2, v.Text.Length - 2);
	                    string[] zooms = zoom_string.Split('-');
	                    if (zooms.Length == 1)
	                    { // there is just one zoom, return it as the lower zoom!
	                        return zooms[0];
	                    }
	                    else if (zooms.Length == 2)
	                    { // get just the lower zoom.
	                        int zoom;
	                        if (zooms[0] != null &&
	                            zooms[0].Length > 0)
	                        { // there is content!
	                            if (int.TryParse(zooms[0], out zoom))
	                            { // zoom value.
	                                return zooms[0];
	                            } // invalid zoom string.
	                            throw new System.ArgumentOutOfRangeException(string.Format("Zoom string {0} cannot be parsed!",
	                                v.Text));
	                        }
	                        return zooms[0];
	                    }
	                    else
	                    { // invalid zoom string.
	                        throw new System.ArgumentOutOfRangeException(string.Format("Zoom string {0} cannot be parsed!",
	                            v.Text));
	                    }
	                }
	            }
	            return string.Empty;
	        }

	        /// <summary>
	        /// Unquote the given text.
	        /// </summary>
	        /// <param name="v"></param>
	        /// <returns></returns>
	        internal static string _unquote(IToken v)
	        {
	            if (v != null &&
	                v.Text != null)
	            { // there is content in the token.
	                if (v.Text.Length < 2)
	                { // how can this be? there are supposed to be quoutes!
	                    throw new System.ArgumentOutOfRangeException("Token must have at least two characters!");
	                }
	                else if (v.Text[0] != '"' && v.Text[0] != '\'')
	                { // how can this be? there are supposed to be quotes!
	                    throw new System.ArgumentOutOfRangeException("Token must have a starting quote!");
	                }
	                else if (v.Text[v.Text.Length - 1] != '"' && v.Text[v.Text.Length - 1] != '\'')
	                { // how can this be? there are supposed to be quotes!
	                    throw new System.ArgumentOutOfRangeException("Token must have a starting quote!");
	                }
	                else
	                { // there are two quotes at the beginning and the end.
	                    return new string(v.Text.ToCharArray(), 1, v.Text.Length - 2);
	                }
	            }
	            return string.Empty;
	        }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_stylesheet();
	partial void LeaveRule_stylesheet();
	// $ANTLR start "stylesheet"
	// MapCSS.g:545:8: public stylesheet : ( entry )* EOF -> ^( STYLESHEET ( entry )* ) ;
	[GrammarRule("stylesheet")]
	public AstParserRuleReturnScope<object, IToken> stylesheet()
	{
		EnterRule_stylesheet();
		EnterRule("stylesheet", 1);
		TraceIn("stylesheet", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<object, IToken> entry1 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF2_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_entry=new RewriteRuleSubtreeStream(adaptor,"rule entry");
		try { DebugEnterRule(GrammarFileName, "stylesheet");
		DebugLocation(545, 1);
		try
		{
			// MapCSS.g:546:2: ( ( entry )* EOF -> ^( STYLESHEET ( entry )* ) )
			DebugEnterAlt(1);
			// MapCSS.g:546:4: ( entry )* EOF
			{
			DebugLocation(546, 4);
			// MapCSS.g:546:4: ( entry )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==CSS_IDENT||LA1_1==IMPORT||LA1_1==OP_MUL))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// MapCSS.g:546:4: entry
					{
					DebugLocation(546, 4);
					PushFollow(Follow._entry_in_stylesheet2690);
					entry1=entry();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_entry.Add(entry1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(546, 11);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_stylesheet2693); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: entry
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 546:15: -> ^( STYLESHEET ( entry )* )
			{
				DebugLocation(546, 18);
				// MapCSS.g:546:18: ^( STYLESHEET ( entry )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(546, 20);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(STYLESHEET, "STYLESHEET"), root_1);

				DebugLocation(546, 31);
				// MapCSS.g:546:31: ( entry )*
				while ( stream_entry.HasNext )
				{
					DebugLocation(546, 31);
					adaptor.AddChild(root_1, stream_entry.NextTree());

				}
				stream_entry.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stylesheet", 1);
			LeaveRule("stylesheet", 1);
			LeaveRule_stylesheet();
		}
		DebugLocation(547, 1);
		} finally { DebugExitRule(GrammarFileName, "stylesheet"); }
		return retval;

	}
	// $ANTLR end "stylesheet"

	partial void EnterRule_entry();
	partial void LeaveRule_entry();
	// $ANTLR start "entry"
	// MapCSS.g:549:1: entry : ( rule | import_statement );
	[GrammarRule("entry")]
	private AstParserRuleReturnScope<object, IToken> entry()
	{
		EnterRule_entry();
		EnterRule("entry", 2);
		TraceIn("entry", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> rule3 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> import_statement4 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "entry");
		DebugLocation(549, 1);
		try
		{
			// MapCSS.g:550:2: ( rule | import_statement )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==CSS_IDENT||LA2_1==OP_MUL))
			{
				alt2 = 1;
			}
			else if ((LA2_1==IMPORT))
			{
				alt2 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:550:4: rule
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(550, 4);
				PushFollow(Follow._rule_in_entry2713);
				rule3=rule();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, rule3.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:551:4: import_statement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(551, 4);
				PushFollow(Follow._import_statement_in_entry2718);
				import_statement4=import_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, import_statement4.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entry", 2);
			LeaveRule("entry", 2);
			LeaveRule_entry();
		}
		DebugLocation(552, 1);
		} finally { DebugExitRule(GrammarFileName, "entry"); }
		return retval;

	}
	// $ANTLR end "entry"

	partial void EnterRule_rule();
	partial void LeaveRule_rule();
	// $ANTLR start "rule"
	// MapCSS.g:554:1: rule : selector ( ',' selector )* ( ',' )* declaration_blocks -> ^( RULE ( selector )* declaration_blocks ) ;
	[GrammarRule("rule")]
	private AstParserRuleReturnScope<object, IToken> rule()
	{
		EnterRule_rule();
		EnterRule("rule", 3);
		TraceIn("rule", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal6 = default(IToken);
		IToken char_literal8 = default(IToken);
		AstParserRuleReturnScope<object, IToken> selector5 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> selector7 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> declaration_blocks9 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal6_tree = default(object);
		object char_literal8_tree = default(object);
		RewriteRuleITokenStream stream_119=new RewriteRuleITokenStream(adaptor,"token 119");
		RewriteRuleSubtreeStream stream_selector=new RewriteRuleSubtreeStream(adaptor,"rule selector");
		RewriteRuleSubtreeStream stream_declaration_blocks=new RewriteRuleSubtreeStream(adaptor,"rule declaration_blocks");
		try { DebugEnterRule(GrammarFileName, "rule");
		DebugLocation(554, 1);
		try
		{
			// MapCSS.g:558:2: ( selector ( ',' selector )* ( ',' )* declaration_blocks -> ^( RULE ( selector )* declaration_blocks ) )
			DebugEnterAlt(1);
			// MapCSS.g:558:4: selector ( ',' selector )* ( ',' )* declaration_blocks
			{
			DebugLocation(558, 4);
			PushFollow(Follow._selector_in_rule2738);
			selector5=selector();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_selector.Add(selector5.Tree);
			DebugLocation(558, 13);
			// MapCSS.g:558:13: ( ',' selector )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==119))
				{
					int LA3_2 = input.LA(2);

					if ((LA3_2==CSS_IDENT||LA3_2==OP_MUL))
					{
						alt3 = 1;
					}


				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// MapCSS.g:558:14: ',' selector
					{
					DebugLocation(558, 14);
					char_literal6=(IToken)Match(input,119,Follow._119_in_rule2741); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_119.Add(char_literal6);

					DebugLocation(558, 18);
					PushFollow(Follow._selector_in_rule2743);
					selector7=selector();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_selector.Add(selector7.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(558, 29);
			// MapCSS.g:558:29: ( ',' )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==119))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// MapCSS.g:558:29: ','
					{
					DebugLocation(558, 29);
					char_literal8=(IToken)Match(input,119,Follow._119_in_rule2747); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_119.Add(char_literal8);


					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(558, 34);
			PushFollow(Follow._declaration_blocks_in_rule2750);
			declaration_blocks9=declaration_blocks();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declaration_blocks.Add(declaration_blocks9.Tree);


			{
			// AST REWRITE
			// elements: selector, declaration_blocks
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 558:53: -> ^( RULE ( selector )* declaration_blocks )
			{
				DebugLocation(558, 56);
				// MapCSS.g:558:56: ^( RULE ( selector )* declaration_blocks )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(558, 58);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RULE, "RULE"), root_1);

				DebugLocation(558, 63);
				// MapCSS.g:558:63: ( selector )*
				while ( stream_selector.HasNext )
				{
					DebugLocation(558, 63);
					adaptor.AddChild(root_1, stream_selector.NextTree());

				}
				stream_selector.Reset();
				DebugLocation(558, 73);
				adaptor.AddChild(root_1, stream_declaration_blocks.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rule", 3);
			LeaveRule("rule", 3);
			LeaveRule_rule();
		}
		DebugLocation(559, 1);
		} finally { DebugExitRule(GrammarFileName, "rule"); }
		return retval;

	}
	// $ANTLR end "rule"

	partial void EnterRule_selector();
	partial void LeaveRule_selector();
	// $ANTLR start "selector"
	// MapCSS.g:561:1: selector : ( simple_selector -> simple_selector | simple_selector simple_selector -> ^( DESCENDANT_COMBINATOR ( simple_selector )+ ) | simple_selector '>' ( link_selector )* simple_selector -> ^( CHILD_COMBINATOR ( simple_selector )+ ( link_selector )* ) | simple_selector '<' simple_selector -> ^( PARENT_COMBINATOR ( simple_selector )+ ) );
	[GrammarRule("selector")]
	private AstParserRuleReturnScope<object, IToken> selector()
	{
		EnterRule_selector();
		EnterRule("selector", 4);
		TraceIn("selector", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal14 = default(IToken);
		IToken char_literal18 = default(IToken);
		AstParserRuleReturnScope<object, IToken> simple_selector10 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simple_selector11 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simple_selector12 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simple_selector13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> link_selector15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simple_selector16 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simple_selector17 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simple_selector19 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal14_tree = default(object);
		object char_literal18_tree = default(object);
		RewriteRuleITokenStream stream_OP_GT=new RewriteRuleITokenStream(adaptor,"token OP_GT");
		RewriteRuleITokenStream stream_OP_LT=new RewriteRuleITokenStream(adaptor,"token OP_LT");
		RewriteRuleSubtreeStream stream_simple_selector=new RewriteRuleSubtreeStream(adaptor,"rule simple_selector");
		RewriteRuleSubtreeStream stream_link_selector=new RewriteRuleSubtreeStream(adaptor,"rule link_selector");
		try { DebugEnterRule(GrammarFileName, "selector");
		DebugLocation(561, 1);
		try
		{
			// MapCSS.g:562:2: ( simple_selector -> simple_selector | simple_selector simple_selector -> ^( DESCENDANT_COMBINATOR ( simple_selector )+ ) | simple_selector '>' ( link_selector )* simple_selector -> ^( CHILD_COMBINATOR ( simple_selector )+ ( link_selector )* ) | simple_selector '<' simple_selector -> ^( PARENT_COMBINATOR ( simple_selector )+ ) )
			int alt6=4;
			try { DebugEnterDecision(6, false);
			try
			{
				alt6 = dfa6.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:562:4: simple_selector
				{
				DebugLocation(562, 4);
				PushFollow(Follow._simple_selector_in_selector2774);
				simple_selector10=simple_selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_simple_selector.Add(simple_selector10.Tree);


				{
				// AST REWRITE
				// elements: simple_selector
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 562:40: -> simple_selector
				{
					DebugLocation(562, 43);
					adaptor.AddChild(root_0, stream_simple_selector.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:563:4: simple_selector simple_selector
				{
				DebugLocation(563, 4);
				PushFollow(Follow._simple_selector_in_selector2803);
				simple_selector11=simple_selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_simple_selector.Add(simple_selector11.Tree);
				DebugLocation(563, 20);
				PushFollow(Follow._simple_selector_in_selector2805);
				simple_selector12=simple_selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_simple_selector.Add(simple_selector12.Tree);


				{
				// AST REWRITE
				// elements: simple_selector
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 563:40: -> ^( DESCENDANT_COMBINATOR ( simple_selector )+ )
				{
					DebugLocation(563, 43);
					// MapCSS.g:563:43: ^( DESCENDANT_COMBINATOR ( simple_selector )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(563, 45);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DESCENDANT_COMBINATOR, "DESCENDANT_COMBINATOR"), root_1);

					DebugLocation(563, 67);
					if (!(stream_simple_selector.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_simple_selector.HasNext )
					{
						DebugLocation(563, 67);
						adaptor.AddChild(root_1, stream_simple_selector.NextTree());

					}
					stream_simple_selector.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:564:4: simple_selector '>' ( link_selector )* simple_selector
				{
				DebugLocation(564, 4);
				PushFollow(Follow._simple_selector_in_selector2823);
				simple_selector13=simple_selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_simple_selector.Add(simple_selector13.Tree);
				DebugLocation(564, 20);
				char_literal14=(IToken)Match(input,OP_GT,Follow._OP_GT_in_selector2825); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_GT.Add(char_literal14);

				DebugLocation(564, 24);
				// MapCSS.g:564:24: ( link_selector )*
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_1 = input.LA(1);

					if ((LA5_1==LBRACKET))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch ( alt5 )
					{
					case 1:
						DebugEnterAlt(1);
						// MapCSS.g:564:24: link_selector
						{
						DebugLocation(564, 24);
						PushFollow(Follow._link_selector_in_selector2827);
						link_selector15=link_selector();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_link_selector.Add(link_selector15.Tree);

						}
						break;

					default:
						goto loop5;
					}
				}

				loop5:
					;

				} finally { DebugExitSubRule(5); }

				DebugLocation(564, 40);
				PushFollow(Follow._simple_selector_in_selector2831);
				simple_selector16=simple_selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_simple_selector.Add(simple_selector16.Tree);


				{
				// AST REWRITE
				// elements: simple_selector, link_selector
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 564:56: -> ^( CHILD_COMBINATOR ( simple_selector )+ ( link_selector )* )
				{
					DebugLocation(564, 59);
					// MapCSS.g:564:59: ^( CHILD_COMBINATOR ( simple_selector )+ ( link_selector )* )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(564, 61);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CHILD_COMBINATOR, "CHILD_COMBINATOR"), root_1);

					DebugLocation(564, 78);
					if (!(stream_simple_selector.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_simple_selector.HasNext )
					{
						DebugLocation(564, 78);
						adaptor.AddChild(root_1, stream_simple_selector.NextTree());

					}
					stream_simple_selector.Reset();
					DebugLocation(564, 95);
					// MapCSS.g:564:95: ( link_selector )*
					while ( stream_link_selector.HasNext )
					{
						DebugLocation(564, 95);
						adaptor.AddChild(root_1, stream_link_selector.NextTree());

					}
					stream_link_selector.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// MapCSS.g:565:4: simple_selector '<' simple_selector
				{
				DebugLocation(565, 4);
				PushFollow(Follow._simple_selector_in_selector2848);
				simple_selector17=simple_selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_simple_selector.Add(simple_selector17.Tree);
				DebugLocation(565, 20);
				char_literal18=(IToken)Match(input,OP_LT,Follow._OP_LT_in_selector2850); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_LT.Add(char_literal18);

				DebugLocation(565, 24);
				PushFollow(Follow._simple_selector_in_selector2852);
				simple_selector19=simple_selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_simple_selector.Add(simple_selector19.Tree);


				{
				// AST REWRITE
				// elements: simple_selector
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 565:40: -> ^( PARENT_COMBINATOR ( simple_selector )+ )
				{
					DebugLocation(565, 43);
					// MapCSS.g:565:43: ^( PARENT_COMBINATOR ( simple_selector )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(565, 45);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARENT_COMBINATOR, "PARENT_COMBINATOR"), root_1);

					DebugLocation(565, 63);
					if (!(stream_simple_selector.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_simple_selector.HasNext )
					{
						DebugLocation(565, 63);
						adaptor.AddChild(root_1, stream_simple_selector.NextTree());

					}
					stream_simple_selector.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selector", 4);
			LeaveRule("selector", 4);
			LeaveRule_selector();
		}
		DebugLocation(566, 1);
		} finally { DebugExitRule(GrammarFileName, "selector"); }
		return retval;

	}
	// $ANTLR end "selector"

	partial void EnterRule_link_selector();
	partial void LeaveRule_link_selector();
	// $ANTLR start "link_selector"
	// MapCSS.g:568:1: link_selector : ( LBRACKET ROLE binary_operator predicate_primitive RBRACKET -> ^( ROLE_SELECTOR binary_operator predicate_primitive ) | LBRACKET INDEX op= int_operator v= POSITIVE_INT RBRACKET -> ^( INDEX_SELECTOR int_operator VALUE_INT[v] ) );
	[GrammarRule("link_selector")]
	private AstParserRuleReturnScope<object, IToken> link_selector()
	{
		EnterRule_link_selector();
		EnterRule("link_selector", 5);
		TraceIn("link_selector", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken v = default(IToken);
		IToken LBRACKET20 = default(IToken);
		IToken ROLE21 = default(IToken);
		IToken RBRACKET24 = default(IToken);
		IToken LBRACKET25 = default(IToken);
		IToken INDEX26 = default(IToken);
		IToken RBRACKET27 = default(IToken);
		AstParserRuleReturnScope<object, IToken> op = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> binary_operator22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> predicate_primitive23 = default(AstParserRuleReturnScope<object, IToken>);

		object v_tree = default(object);
		object LBRACKET20_tree = default(object);
		object ROLE21_tree = default(object);
		object RBRACKET24_tree = default(object);
		object LBRACKET25_tree = default(object);
		object INDEX26_tree = default(object);
		object RBRACKET27_tree = default(object);
		RewriteRuleITokenStream stream_LBRACKET=new RewriteRuleITokenStream(adaptor,"token LBRACKET");
		RewriteRuleITokenStream stream_ROLE=new RewriteRuleITokenStream(adaptor,"token ROLE");
		RewriteRuleITokenStream stream_RBRACKET=new RewriteRuleITokenStream(adaptor,"token RBRACKET");
		RewriteRuleITokenStream stream_INDEX=new RewriteRuleITokenStream(adaptor,"token INDEX");
		RewriteRuleITokenStream stream_POSITIVE_INT=new RewriteRuleITokenStream(adaptor,"token POSITIVE_INT");
		RewriteRuleSubtreeStream stream_binary_operator=new RewriteRuleSubtreeStream(adaptor,"rule binary_operator");
		RewriteRuleSubtreeStream stream_predicate_primitive=new RewriteRuleSubtreeStream(adaptor,"rule predicate_primitive");
		RewriteRuleSubtreeStream stream_int_operator=new RewriteRuleSubtreeStream(adaptor,"rule int_operator");
		try { DebugEnterRule(GrammarFileName, "link_selector");
		DebugLocation(568, 1);
		try
		{
			// MapCSS.g:569:2: ( LBRACKET ROLE binary_operator predicate_primitive RBRACKET -> ^( ROLE_SELECTOR binary_operator predicate_primitive ) | LBRACKET INDEX op= int_operator v= POSITIVE_INT RBRACKET -> ^( INDEX_SELECTOR int_operator VALUE_INT[v] ) )
			int alt7=2;
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==LBRACKET))
			{
				int LA7_2 = input.LA(2);

				if ((LA7_2==ROLE))
				{
					alt7 = 1;
				}
				else if ((LA7_2==INDEX))
				{
					alt7 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 7, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:569:4: LBRACKET ROLE binary_operator predicate_primitive RBRACKET
				{
				DebugLocation(569, 4);
				LBRACKET20=(IToken)Match(input,LBRACKET,Follow._LBRACKET_in_link_selector2872); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACKET.Add(LBRACKET20);

				DebugLocation(569, 13);
				ROLE21=(IToken)Match(input,ROLE,Follow._ROLE_in_link_selector2874); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ROLE.Add(ROLE21);

				DebugLocation(569, 18);
				PushFollow(Follow._binary_operator_in_link_selector2876);
				binary_operator22=binary_operator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_binary_operator.Add(binary_operator22.Tree);
				DebugLocation(569, 34);
				PushFollow(Follow._predicate_primitive_in_link_selector2878);
				predicate_primitive23=predicate_primitive();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_predicate_primitive.Add(predicate_primitive23.Tree);
				DebugLocation(569, 54);
				RBRACKET24=(IToken)Match(input,RBRACKET,Follow._RBRACKET_in_link_selector2880); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACKET.Add(RBRACKET24);



				{
				// AST REWRITE
				// elements: binary_operator, predicate_primitive
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 569:64: -> ^( ROLE_SELECTOR binary_operator predicate_primitive )
				{
					DebugLocation(569, 67);
					// MapCSS.g:569:67: ^( ROLE_SELECTOR binary_operator predicate_primitive )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(569, 69);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ROLE_SELECTOR, "ROLE_SELECTOR"), root_1);

					DebugLocation(569, 83);
					adaptor.AddChild(root_1, stream_binary_operator.NextTree());
					DebugLocation(569, 99);
					adaptor.AddChild(root_1, stream_predicate_primitive.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:570:4: LBRACKET INDEX op= int_operator v= POSITIVE_INT RBRACKET
				{
				DebugLocation(570, 4);
				LBRACKET25=(IToken)Match(input,LBRACKET,Follow._LBRACKET_in_link_selector2896); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACKET.Add(LBRACKET25);

				DebugLocation(570, 13);
				INDEX26=(IToken)Match(input,INDEX,Follow._INDEX_in_link_selector2898); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INDEX.Add(INDEX26);

				DebugLocation(570, 21);
				PushFollow(Follow._int_operator_in_link_selector2902);
				op=int_operator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_int_operator.Add(op.Tree);
				DebugLocation(570, 36);
				v=(IToken)Match(input,POSITIVE_INT,Follow._POSITIVE_INT_in_link_selector2906); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_INT.Add(v);

				DebugLocation(570, 50);
				RBRACKET27=(IToken)Match(input,RBRACKET,Follow._RBRACKET_in_link_selector2908); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACKET.Add(RBRACKET27);



				{
				// AST REWRITE
				// elements: int_operator
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 570:61: -> ^( INDEX_SELECTOR int_operator VALUE_INT[v] )
				{
					DebugLocation(570, 64);
					// MapCSS.g:570:64: ^( INDEX_SELECTOR int_operator VALUE_INT[v] )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(570, 66);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INDEX_SELECTOR, "INDEX_SELECTOR"), root_1);

					DebugLocation(570, 81);
					adaptor.AddChild(root_1, stream_int_operator.NextTree());
					DebugLocation(570, 94);
					adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_INT, v));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("link_selector", 5);
			LeaveRule("link_selector", 5);
			LeaveRule_link_selector();
		}
		DebugLocation(571, 1);
		} finally { DebugExitRule(GrammarFileName, "link_selector"); }
		return retval;

	}
	// $ANTLR end "link_selector"

	partial void EnterRule_layer_id_selector();
	partial void LeaveRule_layer_id_selector();
	// $ANTLR start "layer_id_selector"
	// MapCSS.g:573:1: layer_id_selector : '::' k= CSS_IDENT -> LAYER_ID_SELECTOR[$k] ;
	[GrammarRule("layer_id_selector")]
	private AstParserRuleReturnScope<object, IToken> layer_id_selector()
	{
		EnterRule_layer_id_selector();
		EnterRule("layer_id_selector", 6);
		TraceIn("layer_id_selector", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken k = default(IToken);
		IToken string_literal28 = default(IToken);

		object k_tree = default(object);
		object string_literal28_tree = default(object);
		RewriteRuleITokenStream stream_123=new RewriteRuleITokenStream(adaptor,"token 123");
		RewriteRuleITokenStream stream_CSS_IDENT=new RewriteRuleITokenStream(adaptor,"token CSS_IDENT");
		try { DebugEnterRule(GrammarFileName, "layer_id_selector");
		DebugLocation(573, 1);
		try
		{
			// MapCSS.g:574:2: ( '::' k= CSS_IDENT -> LAYER_ID_SELECTOR[$k] )
			DebugEnterAlt(1);
			// MapCSS.g:574:4: '::' k= CSS_IDENT
			{
			DebugLocation(574, 4);
			string_literal28=(IToken)Match(input,123,Follow._123_in_layer_id_selector2932); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_123.Add(string_literal28);

			DebugLocation(574, 10);
			k=(IToken)Match(input,CSS_IDENT,Follow._CSS_IDENT_in_layer_id_selector2936); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CSS_IDENT.Add(k);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 574:21: -> LAYER_ID_SELECTOR[$k]
			{
				DebugLocation(574, 24);
				adaptor.AddChild(root_0, (object)adaptor.Create(LAYER_ID_SELECTOR, k));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("layer_id_selector", 6);
			LeaveRule("layer_id_selector", 6);
			LeaveRule_layer_id_selector();
		}
		DebugLocation(575, 1);
		} finally { DebugExitRule(GrammarFileName, "layer_id_selector"); }
		return retval;

	}
	// $ANTLR end "layer_id_selector"

	partial void EnterRule_int_operator();
	partial void LeaveRule_int_operator();
	// $ANTLR start "int_operator"
	// MapCSS.g:577:1: int_operator : ( OP_EQ | OP_NEQ | OP_LT | OP_LE | OP_GT | OP_GE );
	[GrammarRule("int_operator")]
	private AstParserRuleReturnScope<object, IToken> int_operator()
	{
		EnterRule_int_operator();
		EnterRule("int_operator", 7);
		TraceIn("int_operator", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set29 = default(IToken);

		object set29_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "int_operator");
		DebugLocation(577, 58);
		try
		{
			// MapCSS.g:577:14: ( OP_EQ | OP_NEQ | OP_LT | OP_LE | OP_GT | OP_GE )
			DebugEnterAlt(1);
			// MapCSS.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(577, 14);

			set29=(IToken)input.LT(1);
			if (input.LA(1)==OP_EQ||(input.LA(1)>=OP_GE && input.LA(1)<=OP_LT)||input.LA(1)==OP_NEQ)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set29));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("int_operator", 7);
			LeaveRule("int_operator", 7);
			LeaveRule_int_operator();
		}
		DebugLocation(577, 58);
		} finally { DebugExitRule(GrammarFileName, "int_operator"); }
		return retval;

	}
	// $ANTLR end "int_operator"

	partial void EnterRule_import_statement();
	partial void LeaveRule_import_statement();
	// $ANTLR start "import_statement"
	// MapCSS.g:579:1: import_statement : IMPORT URL '(' url= quoted ')' id= CSS_IDENT ';' -> ^( IMPORT VALUE_URL[$url.text] VALUE_KEYWORD[$id] ) ;
	[GrammarRule("import_statement")]
	private AstParserRuleReturnScope<object, IToken> import_statement()
	{
		EnterRule_import_statement();
		EnterRule("import_statement", 8);
		TraceIn("import_statement", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken id = default(IToken);
		IToken IMPORT30 = default(IToken);
		IToken URL31 = default(IToken);
		IToken char_literal32 = default(IToken);
		IToken char_literal33 = default(IToken);
		IToken char_literal34 = default(IToken);
		AstParserRuleReturnScope<object, IToken> url = default(AstParserRuleReturnScope<object, IToken>);

		object id_tree = default(object);
		object IMPORT30_tree = default(object);
		object URL31_tree = default(object);
		object char_literal32_tree = default(object);
		object char_literal33_tree = default(object);
		object char_literal34_tree = default(object);
		RewriteRuleITokenStream stream_IMPORT=new RewriteRuleITokenStream(adaptor,"token IMPORT");
		RewriteRuleITokenStream stream_URL=new RewriteRuleITokenStream(adaptor,"token URL");
		RewriteRuleITokenStream stream_117=new RewriteRuleITokenStream(adaptor,"token 117");
		RewriteRuleITokenStream stream_118=new RewriteRuleITokenStream(adaptor,"token 118");
		RewriteRuleITokenStream stream_CSS_IDENT=new RewriteRuleITokenStream(adaptor,"token CSS_IDENT");
		RewriteRuleITokenStream stream_SEMICOLON=new RewriteRuleITokenStream(adaptor,"token SEMICOLON");
		RewriteRuleSubtreeStream stream_quoted=new RewriteRuleSubtreeStream(adaptor,"rule quoted");
		try { DebugEnterRule(GrammarFileName, "import_statement");
		DebugLocation(579, 1);
		try
		{
			// MapCSS.g:580:2: ( IMPORT URL '(' url= quoted ')' id= CSS_IDENT ';' -> ^( IMPORT VALUE_URL[$url.text] VALUE_KEYWORD[$id] ) )
			DebugEnterAlt(1);
			// MapCSS.g:580:4: IMPORT URL '(' url= quoted ')' id= CSS_IDENT ';'
			{
			DebugLocation(580, 4);
			IMPORT30=(IToken)Match(input,IMPORT,Follow._IMPORT_in_import_statement2980); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IMPORT.Add(IMPORT30);

			DebugLocation(580, 11);
			URL31=(IToken)Match(input,URL,Follow._URL_in_import_statement2982); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_URL.Add(URL31);

			DebugLocation(580, 15);
			char_literal32=(IToken)Match(input,117,Follow._117_in_import_statement2984); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_117.Add(char_literal32);

			DebugLocation(580, 22);
			PushFollow(Follow._quoted_in_import_statement2988);
			url=quoted();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_quoted.Add(url.Tree);
			DebugLocation(580, 30);
			char_literal33=(IToken)Match(input,118,Follow._118_in_import_statement2990); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_118.Add(char_literal33);

			DebugLocation(580, 36);
			id=(IToken)Match(input,CSS_IDENT,Follow._CSS_IDENT_in_import_statement2994); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CSS_IDENT.Add(id);

			DebugLocation(580, 47);
			char_literal34=(IToken)Match(input,SEMICOLON,Follow._SEMICOLON_in_import_statement2996); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMICOLON.Add(char_literal34);



			{
			// AST REWRITE
			// elements: IMPORT
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 580:51: -> ^( IMPORT VALUE_URL[$url.text] VALUE_KEYWORD[$id] )
			{
				DebugLocation(580, 54);
				// MapCSS.g:580:54: ^( IMPORT VALUE_URL[$url.text] VALUE_KEYWORD[$id] )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(580, 56);
				root_1 = (object)adaptor.BecomeRoot(stream_IMPORT.NextNode(), root_1);

				DebugLocation(580, 63);
				adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_URL, (url!=null?input.ToString(url.Start,url.Stop):default(string))));
				DebugLocation(580, 84);
				adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_KEYWORD, id));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("import_statement", 8);
			LeaveRule("import_statement", 8);
			LeaveRule_import_statement();
		}
		DebugLocation(581, 1);
		} finally { DebugExitRule(GrammarFileName, "import_statement"); }
		return retval;

	}
	// $ANTLR end "import_statement"

	partial void EnterRule_simple_selector();
	partial void LeaveRule_simple_selector();
	// $ANTLR start "simple_selector"
	// MapCSS.g:583:1: simple_selector : type_selector ( class_selector )? ( zoom_selector )? ( attribute_selector )* ( pseudo_class_selector )* ( layer_id_selector )? -> ^( SIMPLE_SELECTOR type_selector ( class_selector )? ( zoom_selector )? ( attribute_selector )* ( pseudo_class_selector )* ( layer_id_selector )? ) ;
	[GrammarRule("simple_selector")]
	private AstParserRuleReturnScope<object, IToken> simple_selector()
	{
		EnterRule_simple_selector();
		EnterRule("simple_selector", 9);
		TraceIn("simple_selector", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> type_selector35 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> class_selector36 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> zoom_selector37 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> attribute_selector38 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> pseudo_class_selector39 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> layer_id_selector40 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_type_selector=new RewriteRuleSubtreeStream(adaptor,"rule type_selector");
		RewriteRuleSubtreeStream stream_class_selector=new RewriteRuleSubtreeStream(adaptor,"rule class_selector");
		RewriteRuleSubtreeStream stream_zoom_selector=new RewriteRuleSubtreeStream(adaptor,"rule zoom_selector");
		RewriteRuleSubtreeStream stream_attribute_selector=new RewriteRuleSubtreeStream(adaptor,"rule attribute_selector");
		RewriteRuleSubtreeStream stream_pseudo_class_selector=new RewriteRuleSubtreeStream(adaptor,"rule pseudo_class_selector");
		RewriteRuleSubtreeStream stream_layer_id_selector=new RewriteRuleSubtreeStream(adaptor,"rule layer_id_selector");
		try { DebugEnterRule(GrammarFileName, "simple_selector");
		DebugLocation(583, 1);
		try
		{
			// MapCSS.g:584:2: ( type_selector ( class_selector )? ( zoom_selector )? ( attribute_selector )* ( pseudo_class_selector )* ( layer_id_selector )? -> ^( SIMPLE_SELECTOR type_selector ( class_selector )? ( zoom_selector )? ( attribute_selector )* ( pseudo_class_selector )* ( layer_id_selector )? ) )
			DebugEnterAlt(1);
			// MapCSS.g:584:4: type_selector ( class_selector )? ( zoom_selector )? ( attribute_selector )* ( pseudo_class_selector )* ( layer_id_selector )?
			{
			DebugLocation(584, 4);
			PushFollow(Follow._type_selector_in_simple_selector3019);
			type_selector35=type_selector();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_selector.Add(type_selector35.Tree);
			DebugLocation(584, 18);
			// MapCSS.g:584:18: ( class_selector )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==115||LA8_1==121))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:584:18: class_selector
				{
				DebugLocation(584, 18);
				PushFollow(Follow._class_selector_in_simple_selector3021);
				class_selector36=class_selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_class_selector.Add(class_selector36.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(584, 34);
			// MapCSS.g:584:34: ( zoom_selector )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==RANGE))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:584:34: zoom_selector
				{
				DebugLocation(584, 34);
				PushFollow(Follow._zoom_selector_in_simple_selector3024);
				zoom_selector37=zoom_selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_zoom_selector.Add(zoom_selector37.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(584, 49);
			// MapCSS.g:584:49: ( attribute_selector )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==LBRACKET))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// MapCSS.g:584:49: attribute_selector
					{
					DebugLocation(584, 49);
					PushFollow(Follow._attribute_selector_in_simple_selector3027);
					attribute_selector38=attribute_selector();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_attribute_selector.Add(attribute_selector38.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(584, 69);
			// MapCSS.g:584:69: ( pseudo_class_selector )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==COLON||LA11_1==116||LA11_1==122))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// MapCSS.g:584:69: pseudo_class_selector
					{
					DebugLocation(584, 69);
					PushFollow(Follow._pseudo_class_selector_in_simple_selector3030);
					pseudo_class_selector39=pseudo_class_selector();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_pseudo_class_selector.Add(pseudo_class_selector39.Tree);

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(584, 92);
			// MapCSS.g:584:92: ( layer_id_selector )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_1 = input.LA(1);

			if ((LA12_1==123))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:584:92: layer_id_selector
				{
				DebugLocation(584, 92);
				PushFollow(Follow._layer_id_selector_in_simple_selector3033);
				layer_id_selector40=layer_id_selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_layer_id_selector.Add(layer_id_selector40.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(12); }



			{
			// AST REWRITE
			// elements: type_selector, class_selector, zoom_selector, attribute_selector, pseudo_class_selector, layer_id_selector
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 585:7: -> ^( SIMPLE_SELECTOR type_selector ( class_selector )? ( zoom_selector )? ( attribute_selector )* ( pseudo_class_selector )* ( layer_id_selector )? )
			{
				DebugLocation(585, 10);
				// MapCSS.g:585:10: ^( SIMPLE_SELECTOR type_selector ( class_selector )? ( zoom_selector )? ( attribute_selector )* ( pseudo_class_selector )* ( layer_id_selector )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(585, 12);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SIMPLE_SELECTOR, "SIMPLE_SELECTOR"), root_1);

				DebugLocation(585, 28);
				adaptor.AddChild(root_1, stream_type_selector.NextTree());
				DebugLocation(585, 42);
				// MapCSS.g:585:42: ( class_selector )?
				if (stream_class_selector.HasNext)
				{
					DebugLocation(585, 42);
					adaptor.AddChild(root_1, stream_class_selector.NextTree());

				}
				stream_class_selector.Reset();
				DebugLocation(585, 58);
				// MapCSS.g:585:58: ( zoom_selector )?
				if (stream_zoom_selector.HasNext)
				{
					DebugLocation(585, 58);
					adaptor.AddChild(root_1, stream_zoom_selector.NextTree());

				}
				stream_zoom_selector.Reset();
				DebugLocation(585, 73);
				// MapCSS.g:585:73: ( attribute_selector )*
				while ( stream_attribute_selector.HasNext )
				{
					DebugLocation(585, 73);
					adaptor.AddChild(root_1, stream_attribute_selector.NextTree());

				}
				stream_attribute_selector.Reset();
				DebugLocation(585, 93);
				// MapCSS.g:585:93: ( pseudo_class_selector )*
				while ( stream_pseudo_class_selector.HasNext )
				{
					DebugLocation(585, 93);
					adaptor.AddChild(root_1, stream_pseudo_class_selector.NextTree());

				}
				stream_pseudo_class_selector.Reset();
				DebugLocation(585, 116);
				// MapCSS.g:585:116: ( layer_id_selector )?
				if (stream_layer_id_selector.HasNext)
				{
					DebugLocation(585, 116);
					adaptor.AddChild(root_1, stream_layer_id_selector.NextTree());

				}
				stream_layer_id_selector.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("simple_selector", 9);
			LeaveRule("simple_selector", 9);
			LeaveRule_simple_selector();
		}
		DebugLocation(586, 1);
		} finally { DebugExitRule(GrammarFileName, "simple_selector"); }
		return retval;

	}
	// $ANTLR end "simple_selector"

	partial void EnterRule_zoom_selector();
	partial void LeaveRule_zoom_selector();
	// $ANTLR start "zoom_selector"
	// MapCSS.g:588:1: zoom_selector : v= RANGE -> ^( ZOOM_SELECTOR VALUE_INT[_zoomLower($v)] VALUE_INT[_zoomUpper($v)] ) ;
	[GrammarRule("zoom_selector")]
	private AstParserRuleReturnScope<object, IToken> zoom_selector()
	{
		EnterRule_zoom_selector();
		EnterRule("zoom_selector", 10);
		TraceIn("zoom_selector", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken v = default(IToken);

		object v_tree = default(object);
		RewriteRuleITokenStream stream_RANGE=new RewriteRuleITokenStream(adaptor,"token RANGE");
		try { DebugEnterRule(GrammarFileName, "zoom_selector");
		DebugLocation(588, 1);
		try
		{
			// MapCSS.g:589:2: (v= RANGE -> ^( ZOOM_SELECTOR VALUE_INT[_zoomLower($v)] VALUE_INT[_zoomUpper($v)] ) )
			DebugEnterAlt(1);
			// MapCSS.g:589:4: v= RANGE
			{
			DebugLocation(589, 5);
			v=(IToken)Match(input,RANGE,Follow._RANGE_in_zoom_selector3076); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RANGE.Add(v);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 589:12: -> ^( ZOOM_SELECTOR VALUE_INT[_zoomLower($v)] VALUE_INT[_zoomUpper($v)] )
			{
				DebugLocation(589, 15);
				// MapCSS.g:589:15: ^( ZOOM_SELECTOR VALUE_INT[_zoomLower($v)] VALUE_INT[_zoomUpper($v)] )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(589, 17);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ZOOM_SELECTOR, "ZOOM_SELECTOR"), root_1);

				DebugLocation(589, 31);
				adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_INT, _zoomLower(v)));
				DebugLocation(589, 57);
				adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_INT, _zoomUpper(v)));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("zoom_selector", 10);
			LeaveRule("zoom_selector", 10);
			LeaveRule_zoom_selector();
		}
		DebugLocation(590, 1);
		} finally { DebugExitRule(GrammarFileName, "zoom_selector"); }
		return retval;

	}
	// $ANTLR end "zoom_selector"

	partial void EnterRule_quoted();
	partial void LeaveRule_quoted();
	// $ANTLR start "quoted"
	// MapCSS.g:592:1: quoted : (v= DQUOTED_STRING -> VALUE_QUOTED[_unquote($v)] |v= SQUOTED_STRING -> VALUE_QUOTED[_unquote($v)] );
	[GrammarRule("quoted")]
	private AstParserRuleReturnScope<object, IToken> quoted()
	{
		EnterRule_quoted();
		EnterRule("quoted", 11);
		TraceIn("quoted", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken v = default(IToken);

		object v_tree = default(object);
		RewriteRuleITokenStream stream_DQUOTED_STRING=new RewriteRuleITokenStream(adaptor,"token DQUOTED_STRING");
		RewriteRuleITokenStream stream_SQUOTED_STRING=new RewriteRuleITokenStream(adaptor,"token SQUOTED_STRING");
		try { DebugEnterRule(GrammarFileName, "quoted");
		DebugLocation(592, 1);
		try
		{
			// MapCSS.g:593:2: (v= DQUOTED_STRING -> VALUE_QUOTED[_unquote($v)] |v= SQUOTED_STRING -> VALUE_QUOTED[_unquote($v)] )
			int alt13=2;
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==DQUOTED_STRING))
			{
				alt13 = 1;
			}
			else if ((LA13_1==SQUOTED_STRING))
			{
				alt13 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:593:4: v= DQUOTED_STRING
				{
				DebugLocation(593, 5);
				v=(IToken)Match(input,DQUOTED_STRING,Follow._DQUOTED_STRING_in_quoted3101); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DQUOTED_STRING.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 593:23: -> VALUE_QUOTED[_unquote($v)]
				{
					DebugLocation(593, 26);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_QUOTED, _unquote(v)));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:594:4: v= SQUOTED_STRING
				{
				DebugLocation(594, 5);
				v=(IToken)Match(input,SQUOTED_STRING,Follow._SQUOTED_STRING_in_quoted3115); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SQUOTED_STRING.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 594:23: -> VALUE_QUOTED[_unquote($v)]
				{
					DebugLocation(594, 26);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_QUOTED, _unquote(v)));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("quoted", 11);
			LeaveRule("quoted", 11);
			LeaveRule_quoted();
		}
		DebugLocation(595, 1);
		} finally { DebugExitRule(GrammarFileName, "quoted"); }
		return retval;

	}
	// $ANTLR end "quoted"

	partial void EnterRule_cssident();
	partial void LeaveRule_cssident();
	// $ANTLR start "cssident"
	// MapCSS.g:597:1: cssident : v= CSS_IDENT -> VALUE_KEYWORD[$v] ;
	[GrammarRule("cssident")]
	private AstParserRuleReturnScope<object, IToken> cssident()
	{
		EnterRule_cssident();
		EnterRule("cssident", 12);
		TraceIn("cssident", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken v = default(IToken);

		object v_tree = default(object);
		RewriteRuleITokenStream stream_CSS_IDENT=new RewriteRuleITokenStream(adaptor,"token CSS_IDENT");
		try { DebugEnterRule(GrammarFileName, "cssident");
		DebugLocation(597, 1);
		try
		{
			// MapCSS.g:598:2: (v= CSS_IDENT -> VALUE_KEYWORD[$v] )
			DebugEnterAlt(1);
			// MapCSS.g:598:4: v= CSS_IDENT
			{
			DebugLocation(598, 5);
			v=(IToken)Match(input,CSS_IDENT,Follow._CSS_IDENT_in_cssident3137); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CSS_IDENT.Add(v);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 598:18: -> VALUE_KEYWORD[$v]
			{
				DebugLocation(598, 21);
				adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_KEYWORD, v));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("cssident", 12);
			LeaveRule("cssident", 12);
			LeaveRule_cssident();
		}
		DebugLocation(599, 1);
		} finally { DebugExitRule(GrammarFileName, "cssident"); }
		return retval;

	}
	// $ANTLR end "cssident"

	partial void EnterRule_attribute_selector();
	partial void LeaveRule_attribute_selector();
	// $ANTLR start "attribute_selector"
	// MapCSS.g:601:1: attribute_selector : LBRACKET predicate RBRACKET -> ^( ATTRIBUTE_SELECTOR predicate ) ;
	[GrammarRule("attribute_selector")]
	private AstParserRuleReturnScope<object, IToken> attribute_selector()
	{
		EnterRule_attribute_selector();
		EnterRule("attribute_selector", 13);
		TraceIn("attribute_selector", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LBRACKET41 = default(IToken);
		IToken RBRACKET43 = default(IToken);
		AstParserRuleReturnScope<object, IToken> predicate42 = default(AstParserRuleReturnScope<object, IToken>);

		object LBRACKET41_tree = default(object);
		object RBRACKET43_tree = default(object);
		RewriteRuleITokenStream stream_LBRACKET=new RewriteRuleITokenStream(adaptor,"token LBRACKET");
		RewriteRuleITokenStream stream_RBRACKET=new RewriteRuleITokenStream(adaptor,"token RBRACKET");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		try { DebugEnterRule(GrammarFileName, "attribute_selector");
		DebugLocation(601, 1);
		try
		{
			// MapCSS.g:602:2: ( LBRACKET predicate RBRACKET -> ^( ATTRIBUTE_SELECTOR predicate ) )
			DebugEnterAlt(1);
			// MapCSS.g:602:4: LBRACKET predicate RBRACKET
			{
			DebugLocation(602, 4);
			LBRACKET41=(IToken)Match(input,LBRACKET,Follow._LBRACKET_in_attribute_selector3156); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACKET.Add(LBRACKET41);

			DebugLocation(602, 14);
			PushFollow(Follow._predicate_in_attribute_selector3159);
			predicate42=predicate();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_predicate.Add(predicate42.Tree);
			DebugLocation(602, 24);
			RBRACKET43=(IToken)Match(input,RBRACKET,Follow._RBRACKET_in_attribute_selector3161); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACKET.Add(RBRACKET43);



			{
			// AST REWRITE
			// elements: predicate
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 602:35: -> ^( ATTRIBUTE_SELECTOR predicate )
			{
				DebugLocation(602, 38);
				// MapCSS.g:602:38: ^( ATTRIBUTE_SELECTOR predicate )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(602, 40);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ATTRIBUTE_SELECTOR, "ATTRIBUTE_SELECTOR"), root_1);

				DebugLocation(602, 59);
				adaptor.AddChild(root_1, stream_predicate.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("attribute_selector", 13);
			LeaveRule("attribute_selector", 13);
			LeaveRule_attribute_selector();
		}
		DebugLocation(603, 1);
		} finally { DebugExitRule(GrammarFileName, "attribute_selector"); }
		return retval;

	}
	// $ANTLR end "attribute_selector"

	partial void EnterRule_lhs();
	partial void LeaveRule_lhs();
	// $ANTLR start "lhs"
	// MapCSS.g:605:1: lhs : ( quoted |k= CSS_IDENT -> VALUE_KEYWORD[$k] |k= OSM_TAG -> VALUE_KEYWORD[$k] );
	[GrammarRule("lhs")]
	private AstParserRuleReturnScope<object, IToken> lhs()
	{
		EnterRule_lhs();
		EnterRule("lhs", 14);
		TraceIn("lhs", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken k = default(IToken);
		AstParserRuleReturnScope<object, IToken> quoted44 = default(AstParserRuleReturnScope<object, IToken>);

		object k_tree = default(object);
		RewriteRuleITokenStream stream_CSS_IDENT=new RewriteRuleITokenStream(adaptor,"token CSS_IDENT");
		RewriteRuleITokenStream stream_OSM_TAG=new RewriteRuleITokenStream(adaptor,"token OSM_TAG");
		try { DebugEnterRule(GrammarFileName, "lhs");
		DebugLocation(605, 1);
		try
		{
			// MapCSS.g:606:2: ( quoted |k= CSS_IDENT -> VALUE_KEYWORD[$k] |k= OSM_TAG -> VALUE_KEYWORD[$k] )
			int alt14=3;
			try { DebugEnterDecision(14, false);
			switch (input.LA(1))
			{
			case DQUOTED_STRING:
			case SQUOTED_STRING:
				{
				alt14 = 1;
				}
				break;
			case CSS_IDENT:
				{
				alt14 = 2;
				}
				break;
			case OSM_TAG:
				{
				alt14 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 14, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:606:4: quoted
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(606, 4);
				PushFollow(Follow._quoted_in_lhs3182);
				quoted44=quoted();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, quoted44.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:607:4: k= CSS_IDENT
				{
				DebugLocation(607, 5);
				k=(IToken)Match(input,CSS_IDENT,Follow._CSS_IDENT_in_lhs3190); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CSS_IDENT.Add(k);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 607:17: -> VALUE_KEYWORD[$k]
				{
					DebugLocation(607, 20);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_KEYWORD, k));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:608:7: k= OSM_TAG
				{
				DebugLocation(608, 8);
				k=(IToken)Match(input,OSM_TAG,Follow._OSM_TAG_in_lhs3206); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OSM_TAG.Add(k);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 608:20: -> VALUE_KEYWORD[$k]
				{
					DebugLocation(608, 23);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_KEYWORD, k));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lhs", 14);
			LeaveRule("lhs", 14);
			LeaveRule_lhs();
		}
		DebugLocation(609, 1);
		} finally { DebugExitRule(GrammarFileName, "lhs"); }
		return retval;

	}
	// $ANTLR end "lhs"

	partial void EnterRule_predicate();
	partial void LeaveRule_predicate();
	// $ANTLR start "predicate"
	// MapCSS.g:611:1: predicate : ( predicate_ident -> OP_EXIST predicate_ident | quoted -> OP_EXIST quoted | predicate_primitive binary_operator predicate_primitive -> binary_operator ( predicate_primitive )+ | predicate_ident OP_MATCH rhs_match -> OP_MATCH predicate_ident rhs_match | '!' predicate_ident -> OP_NOT_EXIST predicate_ident | predicate_ident '?' -> OP_TRUTHY predicate_ident | '!' quoted -> OP_NOT_EXIST quoted | quoted '?' -> OP_TRUTHY quoted |p= CSS_IDENT '(' quoted ')' -> PREDICATE[$p] quoted );
	[GrammarRule("predicate")]
	private AstParserRuleReturnScope<object, IToken> predicate()
	{
		EnterRule_predicate();
		EnterRule("predicate", 15);
		TraceIn("predicate", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken p = default(IToken);
		IToken OP_MATCH51 = default(IToken);
		IToken char_literal53 = default(IToken);
		IToken char_literal56 = default(IToken);
		IToken char_literal57 = default(IToken);
		IToken char_literal60 = default(IToken);
		IToken char_literal61 = default(IToken);
		IToken char_literal63 = default(IToken);
		AstParserRuleReturnScope<object, IToken> predicate_ident45 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> quoted46 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> predicate_primitive47 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> binary_operator48 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> predicate_primitive49 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> predicate_ident50 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> rhs_match52 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> predicate_ident54 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> predicate_ident55 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> quoted58 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> quoted59 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> quoted62 = default(AstParserRuleReturnScope<object, IToken>);

		object p_tree = default(object);
		object OP_MATCH51_tree = default(object);
		object char_literal53_tree = default(object);
		object char_literal56_tree = default(object);
		object char_literal57_tree = default(object);
		object char_literal60_tree = default(object);
		object char_literal61_tree = default(object);
		object char_literal63_tree = default(object);
		RewriteRuleITokenStream stream_OP_MATCH=new RewriteRuleITokenStream(adaptor,"token OP_MATCH");
		RewriteRuleITokenStream stream_114=new RewriteRuleITokenStream(adaptor,"token 114");
		RewriteRuleITokenStream stream_124=new RewriteRuleITokenStream(adaptor,"token 124");
		RewriteRuleITokenStream stream_CSS_IDENT=new RewriteRuleITokenStream(adaptor,"token CSS_IDENT");
		RewriteRuleITokenStream stream_117=new RewriteRuleITokenStream(adaptor,"token 117");
		RewriteRuleITokenStream stream_118=new RewriteRuleITokenStream(adaptor,"token 118");
		RewriteRuleSubtreeStream stream_predicate_ident=new RewriteRuleSubtreeStream(adaptor,"rule predicate_ident");
		RewriteRuleSubtreeStream stream_quoted=new RewriteRuleSubtreeStream(adaptor,"rule quoted");
		RewriteRuleSubtreeStream stream_predicate_primitive=new RewriteRuleSubtreeStream(adaptor,"rule predicate_primitive");
		RewriteRuleSubtreeStream stream_binary_operator=new RewriteRuleSubtreeStream(adaptor,"rule binary_operator");
		RewriteRuleSubtreeStream stream_rhs_match=new RewriteRuleSubtreeStream(adaptor,"rule rhs_match");
		try { DebugEnterRule(GrammarFileName, "predicate");
		DebugLocation(611, 1);
		try
		{
			// MapCSS.g:612:2: ( predicate_ident -> OP_EXIST predicate_ident | quoted -> OP_EXIST quoted | predicate_primitive binary_operator predicate_primitive -> binary_operator ( predicate_primitive )+ | predicate_ident OP_MATCH rhs_match -> OP_MATCH predicate_ident rhs_match | '!' predicate_ident -> OP_NOT_EXIST predicate_ident | predicate_ident '?' -> OP_TRUTHY predicate_ident | '!' quoted -> OP_NOT_EXIST quoted | quoted '?' -> OP_TRUTHY quoted |p= CSS_IDENT '(' quoted ')' -> PREDICATE[$p] quoted )
			int alt15=9;
			try { DebugEnterDecision(15, false);
			switch (input.LA(1))
			{
			case CSS_IDENT:
				{
				switch (input.LA(2))
				{
				case 117:
					{
					alt15 = 9;
					}
					break;
				case RBRACKET:
					{
					alt15 = 1;
					}
					break;
				case OP_CONTAINS:
				case OP_ENDS_WITH:
				case OP_EQ:
				case OP_GE:
				case OP_GT:
				case OP_LE:
				case OP_LT:
				case OP_NEQ:
				case OP_STARTS_WITH:
				case OP_SUBSTRING:
					{
					alt15 = 3;
					}
					break;
				case OP_MATCH:
					{
					alt15 = 4;
					}
					break;
				case 124:
					{
					alt15 = 6;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 15, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case OSM_TAG:
				{
				switch (input.LA(2))
				{
				case RBRACKET:
					{
					alt15 = 1;
					}
					break;
				case OP_CONTAINS:
				case OP_ENDS_WITH:
				case OP_EQ:
				case OP_GE:
				case OP_GT:
				case OP_LE:
				case OP_LT:
				case OP_NEQ:
				case OP_STARTS_WITH:
				case OP_SUBSTRING:
					{
					alt15 = 3;
					}
					break;
				case OP_MATCH:
					{
					alt15 = 4;
					}
					break;
				case 124:
					{
					alt15 = 6;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 15, 2, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case DQUOTED_STRING:
				{
				switch (input.LA(2))
				{
				case RBRACKET:
					{
					alt15 = 2;
					}
					break;
				case OP_CONTAINS:
				case OP_ENDS_WITH:
				case OP_EQ:
				case OP_GE:
				case OP_GT:
				case OP_LE:
				case OP_LT:
				case OP_NEQ:
				case OP_STARTS_WITH:
				case OP_SUBSTRING:
					{
					alt15 = 3;
					}
					break;
				case 124:
					{
					alt15 = 8;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 15, 3, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case SQUOTED_STRING:
				{
				switch (input.LA(2))
				{
				case RBRACKET:
					{
					alt15 = 2;
					}
					break;
				case OP_CONTAINS:
				case OP_ENDS_WITH:
				case OP_EQ:
				case OP_GE:
				case OP_GT:
				case OP_LE:
				case OP_LT:
				case OP_NEQ:
				case OP_STARTS_WITH:
				case OP_SUBSTRING:
					{
					alt15 = 3;
					}
					break;
				case 124:
					{
					alt15 = 8;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 15, 4, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case NEGATIVE_FLOAT:
			case NEGATIVE_INT:
			case POSITIVE_FLOAT:
			case POSITIVE_INT:
				{
				alt15 = 3;
				}
				break;
			case 114:
				{
				int LA15_2 = input.LA(2);

				if ((LA15_2==CSS_IDENT||LA15_2==OSM_TAG))
				{
					alt15 = 5;
				}
				else if ((LA15_2==DQUOTED_STRING||LA15_2==SQUOTED_STRING))
				{
					alt15 = 7;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:612:4: predicate_ident
				{
				DebugLocation(612, 4);
				PushFollow(Follow._predicate_ident_in_predicate3227);
				predicate_ident45=predicate_ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_predicate_ident.Add(predicate_ident45.Tree);


				{
				// AST REWRITE
				// elements: predicate_ident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 612:40: -> OP_EXIST predicate_ident
				{
					DebugLocation(612, 43);
					adaptor.AddChild(root_0, (object)adaptor.Create(OP_EXIST, "OP_EXIST"));
					DebugLocation(612, 52);
					adaptor.AddChild(root_0, stream_predicate_ident.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:613:4: quoted
				{
				DebugLocation(613, 4);
				PushFollow(Follow._quoted_in_predicate3258);
				quoted46=quoted();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_quoted.Add(quoted46.Tree);


				{
				// AST REWRITE
				// elements: quoted
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 613:35: -> OP_EXIST quoted
				{
					DebugLocation(613, 38);
					adaptor.AddChild(root_0, (object)adaptor.Create(OP_EXIST, "OP_EXIST"));
					DebugLocation(613, 47);
					adaptor.AddChild(root_0, stream_quoted.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:614:4: predicate_primitive binary_operator predicate_primitive
				{
				DebugLocation(614, 4);
				PushFollow(Follow._predicate_primitive_in_predicate3293);
				predicate_primitive47=predicate_primitive();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_predicate_primitive.Add(predicate_primitive47.Tree);
				DebugLocation(614, 24);
				PushFollow(Follow._binary_operator_in_predicate3295);
				binary_operator48=binary_operator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_binary_operator.Add(binary_operator48.Tree);
				DebugLocation(614, 40);
				PushFollow(Follow._predicate_primitive_in_predicate3297);
				predicate_primitive49=predicate_primitive();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_predicate_primitive.Add(predicate_primitive49.Tree);


				{
				// AST REWRITE
				// elements: binary_operator, predicate_primitive
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 614:60: -> binary_operator ( predicate_primitive )+
				{
					DebugLocation(614, 65);
					adaptor.AddChild(root_0, stream_binary_operator.NextTree());
					DebugLocation(614, 81);
					if (!(stream_predicate_primitive.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_predicate_primitive.HasNext )
					{
						DebugLocation(614, 81);
						adaptor.AddChild(root_0, stream_predicate_primitive.NextTree());

					}
					stream_predicate_primitive.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// MapCSS.g:615:4: predicate_ident OP_MATCH rhs_match
				{
				DebugLocation(615, 4);
				PushFollow(Follow._predicate_ident_in_predicate3313);
				predicate_ident50=predicate_ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_predicate_ident.Add(predicate_ident50.Tree);
				DebugLocation(615, 20);
				OP_MATCH51=(IToken)Match(input,OP_MATCH,Follow._OP_MATCH_in_predicate3315); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_MATCH.Add(OP_MATCH51);

				DebugLocation(615, 29);
				PushFollow(Follow._rhs_match_in_predicate3317);
				rhs_match52=rhs_match();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_rhs_match.Add(rhs_match52.Tree);


				{
				// AST REWRITE
				// elements: OP_MATCH, predicate_ident, rhs_match
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 615:40: -> OP_MATCH predicate_ident rhs_match
				{
					DebugLocation(615, 43);
					adaptor.AddChild(root_0, stream_OP_MATCH.NextNode());
					DebugLocation(615, 53);
					adaptor.AddChild(root_0, stream_predicate_ident.NextTree());
					DebugLocation(615, 70);
					adaptor.AddChild(root_0, stream_rhs_match.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// MapCSS.g:616:4: '!' predicate_ident
				{
				DebugLocation(616, 4);
				char_literal53=(IToken)Match(input,114,Follow._114_in_predicate3333); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_114.Add(char_literal53);

				DebugLocation(616, 8);
				PushFollow(Follow._predicate_ident_in_predicate3335);
				predicate_ident54=predicate_ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_predicate_ident.Add(predicate_ident54.Tree);


				{
				// AST REWRITE
				// elements: predicate_ident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 616:40: -> OP_NOT_EXIST predicate_ident
				{
					DebugLocation(616, 43);
					adaptor.AddChild(root_0, (object)adaptor.Create(OP_NOT_EXIST, "OP_NOT_EXIST"));
					DebugLocation(616, 56);
					adaptor.AddChild(root_0, stream_predicate_ident.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// MapCSS.g:617:4: predicate_ident '?'
				{
				DebugLocation(617, 4);
				PushFollow(Follow._predicate_ident_in_predicate3362);
				predicate_ident55=predicate_ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_predicate_ident.Add(predicate_ident55.Tree);
				DebugLocation(617, 20);
				char_literal56=(IToken)Match(input,124,Follow._124_in_predicate3364); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_124.Add(char_literal56);



				{
				// AST REWRITE
				// elements: predicate_ident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 617:40: -> OP_TRUTHY predicate_ident
				{
					DebugLocation(617, 43);
					adaptor.AddChild(root_0, (object)adaptor.Create(OP_TRUTHY, "OP_TRUTHY"));
					DebugLocation(617, 53);
					adaptor.AddChild(root_0, stream_predicate_ident.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// MapCSS.g:618:4: '!' quoted
				{
				DebugLocation(618, 4);
				char_literal57=(IToken)Match(input,114,Follow._114_in_predicate3391); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_114.Add(char_literal57);

				DebugLocation(618, 8);
				PushFollow(Follow._quoted_in_predicate3393);
				quoted58=quoted();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_quoted.Add(quoted58.Tree);


				{
				// AST REWRITE
				// elements: quoted
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 618:35: -> OP_NOT_EXIST quoted
				{
					DebugLocation(618, 38);
					adaptor.AddChild(root_0, (object)adaptor.Create(OP_NOT_EXIST, "OP_NOT_EXIST"));
					DebugLocation(618, 51);
					adaptor.AddChild(root_0, stream_quoted.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// MapCSS.g:619:4: quoted '?'
				{
				DebugLocation(619, 4);
				PushFollow(Follow._quoted_in_predicate3424);
				quoted59=quoted();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_quoted.Add(quoted59.Tree);
				DebugLocation(619, 11);
				char_literal60=(IToken)Match(input,124,Follow._124_in_predicate3426); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_124.Add(char_literal60);



				{
				// AST REWRITE
				// elements: quoted
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 619:34: -> OP_TRUTHY quoted
				{
					DebugLocation(619, 37);
					adaptor.AddChild(root_0, (object)adaptor.Create(OP_TRUTHY, "OP_TRUTHY"));
					DebugLocation(619, 47);
					adaptor.AddChild(root_0, stream_quoted.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// MapCSS.g:620:4: p= CSS_IDENT '(' quoted ')'
				{
				DebugLocation(620, 5);
				p=(IToken)Match(input,CSS_IDENT,Follow._CSS_IDENT_in_predicate3459); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CSS_IDENT.Add(p);

				DebugLocation(620, 16);
				char_literal61=(IToken)Match(input,117,Follow._117_in_predicate3461); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_117.Add(char_literal61);

				DebugLocation(620, 20);
				PushFollow(Follow._quoted_in_predicate3463);
				quoted62=quoted();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_quoted.Add(quoted62.Tree);
				DebugLocation(620, 27);
				char_literal63=(IToken)Match(input,118,Follow._118_in_predicate3465); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_118.Add(char_literal63);



				{
				// AST REWRITE
				// elements: quoted
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 620:40: -> PREDICATE[$p] quoted
				{
					DebugLocation(620, 43);
					adaptor.AddChild(root_0, (object)adaptor.Create(PREDICATE, p));
					DebugLocation(620, 57);
					adaptor.AddChild(root_0, stream_quoted.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("predicate", 15);
			LeaveRule("predicate", 15);
			LeaveRule_predicate();
		}
		DebugLocation(621, 1);
		} finally { DebugExitRule(GrammarFileName, "predicate"); }
		return retval;

	}
	// $ANTLR end "predicate"

	partial void EnterRule_predicate_ident();
	partial void LeaveRule_predicate_ident();
	// $ANTLR start "predicate_ident"
	// MapCSS.g:623:1: predicate_ident : ( cssident |k= OSM_TAG -> VALUE_KEYWORD[$k] );
	[GrammarRule("predicate_ident")]
	private AstParserRuleReturnScope<object, IToken> predicate_ident()
	{
		EnterRule_predicate_ident();
		EnterRule("predicate_ident", 16);
		TraceIn("predicate_ident", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken k = default(IToken);
		AstParserRuleReturnScope<object, IToken> cssident64 = default(AstParserRuleReturnScope<object, IToken>);

		object k_tree = default(object);
		RewriteRuleITokenStream stream_OSM_TAG=new RewriteRuleITokenStream(adaptor,"token OSM_TAG");
		try { DebugEnterRule(GrammarFileName, "predicate_ident");
		DebugLocation(623, 1);
		try
		{
			// MapCSS.g:624:2: ( cssident |k= OSM_TAG -> VALUE_KEYWORD[$k] )
			int alt16=2;
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==CSS_IDENT))
			{
				alt16 = 1;
			}
			else if ((LA16_1==OSM_TAG))
			{
				alt16 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:624:4: cssident
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(624, 4);
				PushFollow(Follow._cssident_in_predicate_ident3494);
				cssident64=cssident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, cssident64.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:625:4: k= OSM_TAG
				{
				DebugLocation(625, 5);
				k=(IToken)Match(input,OSM_TAG,Follow._OSM_TAG_in_predicate_ident3501); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OSM_TAG.Add(k);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 625:16: -> VALUE_KEYWORD[$k]
				{
					DebugLocation(625, 19);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_KEYWORD, k));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("predicate_ident", 16);
			LeaveRule("predicate_ident", 16);
			LeaveRule_predicate_ident();
		}
		DebugLocation(626, 1);
		} finally { DebugExitRule(GrammarFileName, "predicate_ident"); }
		return retval;

	}
	// $ANTLR end "predicate_ident"

	partial void EnterRule_predicate_primitive();
	partial void LeaveRule_predicate_primitive();
	// $ANTLR start "predicate_primitive"
	// MapCSS.g:628:1: predicate_primitive : ( num | predicate_ident | quoted );
	[GrammarRule("predicate_primitive")]
	private AstParserRuleReturnScope<object, IToken> predicate_primitive()
	{
		EnterRule_predicate_primitive();
		EnterRule("predicate_primitive", 17);
		TraceIn("predicate_primitive", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> num65 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> predicate_ident66 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> quoted67 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "predicate_primitive");
		DebugLocation(628, 1);
		try
		{
			// MapCSS.g:629:2: ( num | predicate_ident | quoted )
			int alt17=3;
			try { DebugEnterDecision(17, false);
			switch (input.LA(1))
			{
			case NEGATIVE_FLOAT:
			case NEGATIVE_INT:
			case POSITIVE_FLOAT:
			case POSITIVE_INT:
				{
				alt17 = 1;
				}
				break;
			case CSS_IDENT:
			case OSM_TAG:
				{
				alt17 = 2;
				}
				break;
			case DQUOTED_STRING:
			case SQUOTED_STRING:
				{
				alt17 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:629:4: num
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(629, 4);
				PushFollow(Follow._num_in_predicate_primitive3520);
				num65=num();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, num65.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:630:4: predicate_ident
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(630, 4);
				PushFollow(Follow._predicate_ident_in_predicate_primitive3526);
				predicate_ident66=predicate_ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, predicate_ident66.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:631:4: quoted
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(631, 4);
				PushFollow(Follow._quoted_in_predicate_primitive3531);
				quoted67=quoted();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, quoted67.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("predicate_primitive", 17);
			LeaveRule("predicate_primitive", 17);
			LeaveRule_predicate_primitive();
		}
		DebugLocation(632, 1);
		} finally { DebugExitRule(GrammarFileName, "predicate_primitive"); }
		return retval;

	}
	// $ANTLR end "predicate_primitive"

	partial void EnterRule_rhs_match();
	partial void LeaveRule_rhs_match();
	// $ANTLR start "rhs_match"
	// MapCSS.g:634:1: rhs_match : ( quoted |r= REGEXP -> VALUE_REGEXP[$r] );
	[GrammarRule("rhs_match")]
	private AstParserRuleReturnScope<object, IToken> rhs_match()
	{
		EnterRule_rhs_match();
		EnterRule("rhs_match", 18);
		TraceIn("rhs_match", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken r = default(IToken);
		AstParserRuleReturnScope<object, IToken> quoted68 = default(AstParserRuleReturnScope<object, IToken>);

		object r_tree = default(object);
		RewriteRuleITokenStream stream_REGEXP=new RewriteRuleITokenStream(adaptor,"token REGEXP");
		try { DebugEnterRule(GrammarFileName, "rhs_match");
		DebugLocation(634, 1);
		try
		{
			// MapCSS.g:635:2: ( quoted |r= REGEXP -> VALUE_REGEXP[$r] )
			int alt18=2;
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==DQUOTED_STRING||LA18_1==SQUOTED_STRING))
			{
				alt18 = 1;
			}
			else if ((LA18_1==REGEXP))
			{
				alt18 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 18, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:635:4: quoted
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(635, 4);
				PushFollow(Follow._quoted_in_rhs_match3543);
				quoted68=quoted();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, quoted68.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:636:4: r= REGEXP
				{
				DebugLocation(636, 5);
				r=(IToken)Match(input,REGEXP,Follow._REGEXP_in_rhs_match3550); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_REGEXP.Add(r);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 636:33: -> VALUE_REGEXP[$r]
				{
					DebugLocation(636, 36);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_REGEXP, r));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rhs_match", 18);
			LeaveRule("rhs_match", 18);
			LeaveRule_rhs_match();
		}
		DebugLocation(637, 1);
		} finally { DebugExitRule(GrammarFileName, "rhs_match"); }
		return retval;

	}
	// $ANTLR end "rhs_match"

	partial void EnterRule_binary_operator();
	partial void LeaveRule_binary_operator();
	// $ANTLR start "binary_operator"
	// MapCSS.g:639:1: binary_operator : ( OP_EQ | OP_NEQ | OP_LT | OP_GT | OP_LE | OP_GE | OP_STARTS_WITH | OP_ENDS_WITH | OP_SUBSTRING | OP_CONTAINS );
	[GrammarRule("binary_operator")]
	private AstParserRuleReturnScope<object, IToken> binary_operator()
	{
		EnterRule_binary_operator();
		EnterRule("binary_operator", 19);
		TraceIn("binary_operator", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set69 = default(IToken);

		object set69_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "binary_operator");
		DebugLocation(639, 1);
		try
		{
			// MapCSS.g:640:2: ( OP_EQ | OP_NEQ | OP_LT | OP_GT | OP_LE | OP_GE | OP_STARTS_WITH | OP_ENDS_WITH | OP_SUBSTRING | OP_CONTAINS )
			DebugEnterAlt(1);
			// MapCSS.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(640, 2);

			set69=(IToken)input.LT(1);
			if (input.LA(1)==OP_CONTAINS||(input.LA(1)>=OP_ENDS_WITH && input.LA(1)<=OP_EQ)||(input.LA(1)>=OP_GE && input.LA(1)<=OP_LT)||input.LA(1)==OP_NEQ||(input.LA(1)>=OP_STARTS_WITH && input.LA(1)<=OP_SUBSTRING))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set69));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("binary_operator", 19);
			LeaveRule("binary_operator", 19);
			LeaveRule_binary_operator();
		}
		DebugLocation(643, 1);
		} finally { DebugExitRule(GrammarFileName, "binary_operator"); }
		return retval;

	}
	// $ANTLR end "binary_operator"

	partial void EnterRule_class_selector();
	partial void LeaveRule_class_selector();
	// $ANTLR start "class_selector"
	// MapCSS.g:645:1: class_selector : ( '!.' cssident -> ^( CLASS_SELECTOR OP_NOT_EXIST cssident ) | '.' cssident -> ^( CLASS_SELECTOR OP_EXIST cssident ) );
	[GrammarRule("class_selector")]
	private AstParserRuleReturnScope<object, IToken> class_selector()
	{
		EnterRule_class_selector();
		EnterRule("class_selector", 20);
		TraceIn("class_selector", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal70 = default(IToken);
		IToken char_literal72 = default(IToken);
		AstParserRuleReturnScope<object, IToken> cssident71 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> cssident73 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal70_tree = default(object);
		object char_literal72_tree = default(object);
		RewriteRuleITokenStream stream_115=new RewriteRuleITokenStream(adaptor,"token 115");
		RewriteRuleITokenStream stream_121=new RewriteRuleITokenStream(adaptor,"token 121");
		RewriteRuleSubtreeStream stream_cssident=new RewriteRuleSubtreeStream(adaptor,"rule cssident");
		try { DebugEnterRule(GrammarFileName, "class_selector");
		DebugLocation(645, 1);
		try
		{
			// MapCSS.g:646:2: ( '!.' cssident -> ^( CLASS_SELECTOR OP_NOT_EXIST cssident ) | '.' cssident -> ^( CLASS_SELECTOR OP_EXIST cssident ) )
			int alt19=2;
			try { DebugEnterDecision(19, false);
			int LA19_1 = input.LA(1);

			if ((LA19_1==115))
			{
				alt19 = 1;
			}
			else if ((LA19_1==121))
			{
				alt19 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 19, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:646:4: '!.' cssident
				{
				DebugLocation(646, 4);
				string_literal70=(IToken)Match(input,115,Follow._115_in_class_selector3648); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_115.Add(string_literal70);

				DebugLocation(646, 10);
				PushFollow(Follow._cssident_in_class_selector3651);
				cssident71=cssident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_cssident.Add(cssident71.Tree);


				{
				// AST REWRITE
				// elements: cssident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 646:20: -> ^( CLASS_SELECTOR OP_NOT_EXIST cssident )
				{
					DebugLocation(646, 23);
					// MapCSS.g:646:23: ^( CLASS_SELECTOR OP_NOT_EXIST cssident )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(646, 25);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CLASS_SELECTOR, "CLASS_SELECTOR"), root_1);

					DebugLocation(646, 40);
					adaptor.AddChild(root_1, (object)adaptor.Create(OP_NOT_EXIST, "OP_NOT_EXIST"));
					DebugLocation(646, 53);
					adaptor.AddChild(root_1, stream_cssident.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:647:5: '.' cssident
				{
				DebugLocation(647, 5);
				char_literal72=(IToken)Match(input,121,Follow._121_in_class_selector3668); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_121.Add(char_literal72);

				DebugLocation(647, 10);
				PushFollow(Follow._cssident_in_class_selector3671);
				cssident73=cssident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_cssident.Add(cssident73.Tree);


				{
				// AST REWRITE
				// elements: cssident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 647:20: -> ^( CLASS_SELECTOR OP_EXIST cssident )
				{
					DebugLocation(647, 23);
					// MapCSS.g:647:23: ^( CLASS_SELECTOR OP_EXIST cssident )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(647, 25);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CLASS_SELECTOR, "CLASS_SELECTOR"), root_1);

					DebugLocation(647, 40);
					adaptor.AddChild(root_1, (object)adaptor.Create(OP_EXIST, "OP_EXIST"));
					DebugLocation(647, 53);
					adaptor.AddChild(root_1, stream_cssident.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("class_selector", 20);
			LeaveRule("class_selector", 20);
			LeaveRule_class_selector();
		}
		DebugLocation(648, 1);
		} finally { DebugExitRule(GrammarFileName, "class_selector"); }
		return retval;

	}
	// $ANTLR end "class_selector"

	partial void EnterRule_pseudo_class_selector();
	partial void LeaveRule_pseudo_class_selector();
	// $ANTLR start "pseudo_class_selector"
	// MapCSS.g:650:1: pseudo_class_selector : ( ':!' cssident -> ^( PSEUDO_CLASS_SELECTOR OP_NOT_EXIST cssident ) | '!:' cssident -> ^( PSEUDO_CLASS_SELECTOR OP_NOT_EXIST cssident ) | ':' cssident -> ^( PSEUDO_CLASS_SELECTOR OP_EXIST cssident ) );
	[GrammarRule("pseudo_class_selector")]
	private AstParserRuleReturnScope<object, IToken> pseudo_class_selector()
	{
		EnterRule_pseudo_class_selector();
		EnterRule("pseudo_class_selector", 21);
		TraceIn("pseudo_class_selector", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal74 = default(IToken);
		IToken string_literal76 = default(IToken);
		IToken char_literal78 = default(IToken);
		AstParserRuleReturnScope<object, IToken> cssident75 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> cssident77 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> cssident79 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal74_tree = default(object);
		object string_literal76_tree = default(object);
		object char_literal78_tree = default(object);
		RewriteRuleITokenStream stream_122=new RewriteRuleITokenStream(adaptor,"token 122");
		RewriteRuleITokenStream stream_116=new RewriteRuleITokenStream(adaptor,"token 116");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_cssident=new RewriteRuleSubtreeStream(adaptor,"rule cssident");
		try { DebugEnterRule(GrammarFileName, "pseudo_class_selector");
		DebugLocation(650, 1);
		try
		{
			// MapCSS.g:651:5: ( ':!' cssident -> ^( PSEUDO_CLASS_SELECTOR OP_NOT_EXIST cssident ) | '!:' cssident -> ^( PSEUDO_CLASS_SELECTOR OP_NOT_EXIST cssident ) | ':' cssident -> ^( PSEUDO_CLASS_SELECTOR OP_EXIST cssident ) )
			int alt20=3;
			try { DebugEnterDecision(20, false);
			switch (input.LA(1))
			{
			case 122:
				{
				alt20 = 1;
				}
				break;
			case 116:
				{
				alt20 = 2;
				}
				break;
			case COLON:
				{
				alt20 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 20, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:651:7: ':!' cssident
				{
				DebugLocation(651, 7);
				string_literal74=(IToken)Match(input,122,Follow._122_in_pseudo_class_selector3700); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_122.Add(string_literal74);

				DebugLocation(651, 12);
				PushFollow(Follow._cssident_in_pseudo_class_selector3702);
				cssident75=cssident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_cssident.Add(cssident75.Tree);


				{
				// AST REWRITE
				// elements: cssident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 651:23: -> ^( PSEUDO_CLASS_SELECTOR OP_NOT_EXIST cssident )
				{
					DebugLocation(651, 26);
					// MapCSS.g:651:26: ^( PSEUDO_CLASS_SELECTOR OP_NOT_EXIST cssident )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(651, 28);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PSEUDO_CLASS_SELECTOR, "PSEUDO_CLASS_SELECTOR"), root_1);

					DebugLocation(651, 50);
					adaptor.AddChild(root_1, (object)adaptor.Create(OP_NOT_EXIST, "OP_NOT_EXIST"));
					DebugLocation(651, 63);
					adaptor.AddChild(root_1, stream_cssident.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:652:7: '!:' cssident
				{
				DebugLocation(652, 7);
				string_literal76=(IToken)Match(input,116,Follow._116_in_pseudo_class_selector3723); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_116.Add(string_literal76);

				DebugLocation(652, 12);
				PushFollow(Follow._cssident_in_pseudo_class_selector3725);
				cssident77=cssident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_cssident.Add(cssident77.Tree);


				{
				// AST REWRITE
				// elements: cssident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 652:23: -> ^( PSEUDO_CLASS_SELECTOR OP_NOT_EXIST cssident )
				{
					DebugLocation(652, 26);
					// MapCSS.g:652:26: ^( PSEUDO_CLASS_SELECTOR OP_NOT_EXIST cssident )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(652, 28);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PSEUDO_CLASS_SELECTOR, "PSEUDO_CLASS_SELECTOR"), root_1);

					DebugLocation(652, 50);
					adaptor.AddChild(root_1, (object)adaptor.Create(OP_NOT_EXIST, "OP_NOT_EXIST"));
					DebugLocation(652, 63);
					adaptor.AddChild(root_1, stream_cssident.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:653:4: ':' cssident
				{
				DebugLocation(653, 4);
				char_literal78=(IToken)Match(input,COLON,Follow._COLON_in_pseudo_class_selector3742); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(char_literal78);

				DebugLocation(653, 8);
				PushFollow(Follow._cssident_in_pseudo_class_selector3744);
				cssident79=cssident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_cssident.Add(cssident79.Tree);


				{
				// AST REWRITE
				// elements: cssident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 653:19: -> ^( PSEUDO_CLASS_SELECTOR OP_EXIST cssident )
				{
					DebugLocation(653, 22);
					// MapCSS.g:653:22: ^( PSEUDO_CLASS_SELECTOR OP_EXIST cssident )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(653, 24);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PSEUDO_CLASS_SELECTOR, "PSEUDO_CLASS_SELECTOR"), root_1);

					DebugLocation(653, 46);
					adaptor.AddChild(root_1, (object)adaptor.Create(OP_EXIST, "OP_EXIST"));
					DebugLocation(653, 55);
					adaptor.AddChild(root_1, stream_cssident.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("pseudo_class_selector", 21);
			LeaveRule("pseudo_class_selector", 21);
			LeaveRule_pseudo_class_selector();
		}
		DebugLocation(654, 1);
		} finally { DebugExitRule(GrammarFileName, "pseudo_class_selector"); }
		return retval;

	}
	// $ANTLR end "pseudo_class_selector"

	partial void EnterRule_type_selector();
	partial void LeaveRule_type_selector();
	// $ANTLR start "type_selector"
	// MapCSS.g:656:1: type_selector : (v= CSS_IDENT -> TYPE_SELECTOR[$v] |v= '*' -> TYPE_SELECTOR[$v] );
	[GrammarRule("type_selector")]
	private AstParserRuleReturnScope<object, IToken> type_selector()
	{
		EnterRule_type_selector();
		EnterRule("type_selector", 22);
		TraceIn("type_selector", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken v = default(IToken);

		object v_tree = default(object);
		RewriteRuleITokenStream stream_CSS_IDENT=new RewriteRuleITokenStream(adaptor,"token CSS_IDENT");
		RewriteRuleITokenStream stream_OP_MUL=new RewriteRuleITokenStream(adaptor,"token OP_MUL");
		try { DebugEnterRule(GrammarFileName, "type_selector");
		DebugLocation(656, 1);
		try
		{
			// MapCSS.g:660:5: (v= CSS_IDENT -> TYPE_SELECTOR[$v] |v= '*' -> TYPE_SELECTOR[$v] )
			int alt21=2;
			try { DebugEnterDecision(21, false);
			int LA21_1 = input.LA(1);

			if ((LA21_1==CSS_IDENT))
			{
				alt21 = 1;
			}
			else if ((LA21_1==OP_MUL))
			{
				alt21 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:660:7: v= CSS_IDENT
				{
				DebugLocation(660, 8);
				v=(IToken)Match(input,CSS_IDENT,Follow._CSS_IDENT_in_type_selector3779); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CSS_IDENT.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 660:22: -> TYPE_SELECTOR[$v]
				{
					DebugLocation(660, 25);
					adaptor.AddChild(root_0, (object)adaptor.Create(TYPE_SELECTOR, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:661:7: v= '*'
				{
				DebugLocation(661, 8);
				v=(IToken)Match(input,OP_MUL,Follow._OP_MUL_in_type_selector3797); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_MUL.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 661:22: -> TYPE_SELECTOR[$v]
				{
					DebugLocation(661, 25);
					adaptor.AddChild(root_0, (object)adaptor.Create(TYPE_SELECTOR, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_selector", 22);
			LeaveRule("type_selector", 22);
			LeaveRule_type_selector();
		}
		DebugLocation(662, 1);
		} finally { DebugExitRule(GrammarFileName, "type_selector"); }
		return retval;

	}
	// $ANTLR end "type_selector"

	partial void EnterRule_declaration_blocks();
	partial void LeaveRule_declaration_blocks();
	// $ANTLR start "declaration_blocks"
	// MapCSS.g:664:1: declaration_blocks : declaration_block ( declaration_block )* -> ( declaration_block )* ;
	[GrammarRule("declaration_blocks")]
	private AstParserRuleReturnScope<object, IToken> declaration_blocks()
	{
		EnterRule_declaration_blocks();
		EnterRule("declaration_blocks", 23);
		TraceIn("declaration_blocks", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declaration_block80 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> declaration_block81 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_declaration_block=new RewriteRuleSubtreeStream(adaptor,"rule declaration_block");
		try { DebugEnterRule(GrammarFileName, "declaration_blocks");
		DebugLocation(664, 1);
		try
		{
			// MapCSS.g:665:2: ( declaration_block ( declaration_block )* -> ( declaration_block )* )
			DebugEnterAlt(1);
			// MapCSS.g:665:4: declaration_block ( declaration_block )*
			{
			DebugLocation(665, 4);
			PushFollow(Follow._declaration_block_in_declaration_blocks3822);
			declaration_block80=declaration_block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declaration_block.Add(declaration_block80.Tree);
			DebugLocation(665, 22);
			// MapCSS.g:665:22: ( declaration_block )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==LBRACE))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// MapCSS.g:665:23: declaration_block
					{
					DebugLocation(665, 23);
					PushFollow(Follow._declaration_block_in_declaration_blocks3825);
					declaration_block81=declaration_block();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_declaration_block.Add(declaration_block81.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }



			{
			// AST REWRITE
			// elements: declaration_block
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 665:43: -> ( declaration_block )*
			{
				DebugLocation(665, 46);
				// MapCSS.g:665:46: ( declaration_block )*
				while ( stream_declaration_block.HasNext )
				{
					DebugLocation(665, 46);
					adaptor.AddChild(root_0, stream_declaration_block.NextTree());

				}
				stream_declaration_block.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration_blocks", 23);
			LeaveRule("declaration_blocks", 23);
			LeaveRule_declaration_blocks();
		}
		DebugLocation(666, 1);
		} finally { DebugExitRule(GrammarFileName, "declaration_blocks"); }
		return retval;

	}
	// $ANTLR end "declaration_blocks"

	partial void EnterRule_declaration_block();
	partial void LeaveRule_declaration_block();
	// $ANTLR start "declaration_block"
	// MapCSS.g:668:1: declaration_block : (l= LBRACE declarations RBRACE -> ^( DECLARATION_BLOCK[$l] declarations ) |l= LBRACE RBRACE -> ^( DECLARATION_BLOCK[$l] ) );
	[GrammarRule("declaration_block")]
	private AstParserRuleReturnScope<object, IToken> declaration_block()
	{
		EnterRule_declaration_block();
		EnterRule("declaration_block", 24);
		TraceIn("declaration_block", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken l = default(IToken);
		IToken RBRACE83 = default(IToken);
		IToken RBRACE84 = default(IToken);
		AstParserRuleReturnScope<object, IToken> declarations82 = default(AstParserRuleReturnScope<object, IToken>);

		object l_tree = default(object);
		object RBRACE83_tree = default(object);
		object RBRACE84_tree = default(object);
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_declarations=new RewriteRuleSubtreeStream(adaptor,"rule declarations");
		try { DebugEnterRule(GrammarFileName, "declaration_block");
		DebugLocation(668, 1);
		try
		{
			// MapCSS.g:673:2: (l= LBRACE declarations RBRACE -> ^( DECLARATION_BLOCK[$l] declarations ) |l= LBRACE RBRACE -> ^( DECLARATION_BLOCK[$l] ) )
			int alt23=2;
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1==LBRACE))
			{
				int LA23_2 = input.LA(2);

				if ((LA23_2==RBRACE))
				{
					alt23 = 2;
				}
				else if ((LA23_2==CSS_IDENT))
				{
					alt23 = 1;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 23, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 23, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:673:5: l= LBRACE declarations RBRACE
				{
				DebugLocation(673, 6);
				l=(IToken)Match(input,LBRACE,Follow._LBRACE_in_declaration_block3852); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACE.Add(l);

				DebugLocation(673, 14);
				PushFollow(Follow._declarations_in_declaration_block3854);
				declarations82=declarations();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_declarations.Add(declarations82.Tree);
				DebugLocation(673, 27);
				RBRACE83=(IToken)Match(input,RBRACE,Follow._RBRACE_in_declaration_block3856); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACE.Add(RBRACE83);



				{
				// AST REWRITE
				// elements: declarations
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 673:34: -> ^( DECLARATION_BLOCK[$l] declarations )
				{
					DebugLocation(673, 37);
					// MapCSS.g:673:37: ^( DECLARATION_BLOCK[$l] declarations )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(673, 39);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECLARATION_BLOCK, l), root_1);

					DebugLocation(673, 61);
					adaptor.AddChild(root_1, stream_declarations.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:674:5: l= LBRACE RBRACE
				{
				DebugLocation(674, 6);
				l=(IToken)Match(input,LBRACE,Follow._LBRACE_in_declaration_block3873); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACE.Add(l);

				DebugLocation(674, 14);
				RBRACE84=(IToken)Match(input,RBRACE,Follow._RBRACE_in_declaration_block3875); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACE.Add(RBRACE84);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 674:34: -> ^( DECLARATION_BLOCK[$l] )
				{
					DebugLocation(674, 37);
					// MapCSS.g:674:37: ^( DECLARATION_BLOCK[$l] )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(674, 39);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECLARATION_BLOCK, l), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration_block", 24);
			LeaveRule("declaration_block", 24);
			LeaveRule_declaration_block();
		}
		DebugLocation(675, 1);
		} finally { DebugExitRule(GrammarFileName, "declaration_block"); }
		return retval;

	}
	// $ANTLR end "declaration_block"

	partial void EnterRule_declarations();
	partial void LeaveRule_declarations();
	// $ANTLR start "declarations"
	// MapCSS.g:677:1: declarations : declaration ( SEMICOLON declaration )* ( ';' )* -> ( declaration )* ;
	[GrammarRule("declarations")]
	private AstParserRuleReturnScope<object, IToken> declarations()
	{
		EnterRule_declarations();
		EnterRule("declarations", 25);
		TraceIn("declarations", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMICOLON86 = default(IToken);
		IToken char_literal88 = default(IToken);
		AstParserRuleReturnScope<object, IToken> declaration85 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> declaration87 = default(AstParserRuleReturnScope<object, IToken>);

		object SEMICOLON86_tree = default(object);
		object char_literal88_tree = default(object);
		RewriteRuleITokenStream stream_SEMICOLON=new RewriteRuleITokenStream(adaptor,"token SEMICOLON");
		RewriteRuleSubtreeStream stream_declaration=new RewriteRuleSubtreeStream(adaptor,"rule declaration");
		try { DebugEnterRule(GrammarFileName, "declarations");
		DebugLocation(677, 1);
		try
		{
			// MapCSS.g:678:2: ( declaration ( SEMICOLON declaration )* ( ';' )* -> ( declaration )* )
			DebugEnterAlt(1);
			// MapCSS.g:678:4: declaration ( SEMICOLON declaration )* ( ';' )*
			{
			DebugLocation(678, 4);
			PushFollow(Follow._declaration_in_declarations3906);
			declaration85=declaration();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declaration.Add(declaration85.Tree);
			DebugLocation(678, 16);
			// MapCSS.g:678:16: ( SEMICOLON declaration )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==SEMICOLON))
				{
					int LA24_2 = input.LA(2);

					if ((LA24_2==CSS_IDENT))
					{
						alt24 = 1;
					}


				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// MapCSS.g:678:17: SEMICOLON declaration
					{
					DebugLocation(678, 17);
					SEMICOLON86=(IToken)Match(input,SEMICOLON,Follow._SEMICOLON_in_declarations3909); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SEMICOLON.Add(SEMICOLON86);

					DebugLocation(678, 27);
					PushFollow(Follow._declaration_in_declarations3911);
					declaration87=declaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_declaration.Add(declaration87.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }

			DebugLocation(678, 41);
			// MapCSS.g:678:41: ( ';' )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_1 = input.LA(1);

				if ((LA25_1==SEMICOLON))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// MapCSS.g:678:41: ';'
					{
					DebugLocation(678, 41);
					char_literal88=(IToken)Match(input,SEMICOLON,Follow._SEMICOLON_in_declarations3915); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SEMICOLON.Add(char_literal88);


					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }



			{
			// AST REWRITE
			// elements: declaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 678:47: -> ( declaration )*
			{
				DebugLocation(678, 50);
				// MapCSS.g:678:50: ( declaration )*
				while ( stream_declaration.HasNext )
				{
					DebugLocation(678, 50);
					adaptor.AddChild(root_0, stream_declaration.NextTree());

				}
				stream_declaration.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declarations", 25);
			LeaveRule("declarations", 25);
			LeaveRule_declarations();
		}
		DebugLocation(679, 1);
		} finally { DebugExitRule(GrammarFileName, "declarations"); }
		return retval;

	}
	// $ANTLR end "declarations"

	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();
	// $ANTLR start "declaration"
	// MapCSS.g:681:1: declaration : declaration_property COLON declaration_value -> ^( DECLARATION declaration_property declaration_value ) ;
	[GrammarRule("declaration")]
	private AstParserRuleReturnScope<object, IToken> declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 26);
		TraceIn("declaration", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COLON90 = default(IToken);
		AstParserRuleReturnScope<object, IToken> declaration_property89 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> declaration_value91 = default(AstParserRuleReturnScope<object, IToken>);

		object COLON90_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_declaration_property=new RewriteRuleSubtreeStream(adaptor,"rule declaration_property");
		RewriteRuleSubtreeStream stream_declaration_value=new RewriteRuleSubtreeStream(adaptor,"rule declaration_value");
		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(681, 1);
		try
		{
			// MapCSS.g:682:2: ( declaration_property COLON declaration_value -> ^( DECLARATION declaration_property declaration_value ) )
			DebugEnterAlt(1);
			// MapCSS.g:682:4: declaration_property COLON declaration_value
			{
			DebugLocation(682, 4);
			PushFollow(Follow._declaration_property_in_declaration3933);
			declaration_property89=declaration_property();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declaration_property.Add(declaration_property89.Tree);
			DebugLocation(682, 25);
			COLON90=(IToken)Match(input,COLON,Follow._COLON_in_declaration3935); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON90);

			DebugLocation(682, 31);
			PushFollow(Follow._declaration_value_in_declaration3937);
			declaration_value91=declaration_value();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declaration_value.Add(declaration_value91.Tree);


			{
			// AST REWRITE
			// elements: declaration_property, declaration_value
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 682:50: -> ^( DECLARATION declaration_property declaration_value )
			{
				DebugLocation(682, 53);
				// MapCSS.g:682:53: ^( DECLARATION declaration_property declaration_value )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(682, 55);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECLARATION, "DECLARATION"), root_1);

				DebugLocation(682, 67);
				adaptor.AddChild(root_1, stream_declaration_property.NextTree());
				DebugLocation(682, 88);
				adaptor.AddChild(root_1, stream_declaration_value.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration", 26);
			LeaveRule("declaration", 26);
			LeaveRule_declaration();
		}
		DebugLocation(683, 1);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return retval;

	}
	// $ANTLR end "declaration"

	partial void EnterRule_declaration_property();
	partial void LeaveRule_declaration_property();
	// $ANTLR start "declaration_property"
	// MapCSS.g:685:1: declaration_property : cssident ;
	[GrammarRule("declaration_property")]
	private AstParserRuleReturnScope<object, IToken> declaration_property()
	{
		EnterRule_declaration_property();
		EnterRule("declaration_property", 27);
		TraceIn("declaration_property", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> cssident92 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declaration_property");
		DebugLocation(685, 1);
		try
		{
			// MapCSS.g:686:2: ( cssident )
			DebugEnterAlt(1);
			// MapCSS.g:686:4: cssident
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(686, 4);
			PushFollow(Follow._cssident_in_declaration_property3959);
			cssident92=cssident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, cssident92.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration_property", 27);
			LeaveRule("declaration_property", 27);
			LeaveRule_declaration_property();
		}
		DebugLocation(687, 1);
		} finally { DebugExitRule(GrammarFileName, "declaration_property"); }
		return retval;

	}
	// $ANTLR end "declaration_property"

	partial void EnterRule_declaration_value();
	partial void LeaveRule_declaration_value();
	// $ANTLR start "declaration_value"
	// MapCSS.g:689:1: declaration_value : ( single_value | single_value ',' single_value ( ',' single_value )* -> ^( VALUE_LIST ( single_value )* ) | EVAL '(' expr ')' -> ^( EVAL_CALL expr ) | LIST '(' single_value ( ',' single_value )* ')' -> ^( VALUE_LIST ( single_value )* ) | LIST '(' ')' -> ^( VALUE_LIST ) );
	[GrammarRule("declaration_value")]
	private AstParserRuleReturnScope<object, IToken> declaration_value()
	{
		EnterRule_declaration_value();
		EnterRule("declaration_value", 28);
		TraceIn("declaration_value", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal95 = default(IToken);
		IToken char_literal97 = default(IToken);
		IToken EVAL99 = default(IToken);
		IToken char_literal100 = default(IToken);
		IToken char_literal102 = default(IToken);
		IToken LIST103 = default(IToken);
		IToken char_literal104 = default(IToken);
		IToken char_literal106 = default(IToken);
		IToken char_literal108 = default(IToken);
		IToken LIST109 = default(IToken);
		IToken char_literal110 = default(IToken);
		IToken char_literal111 = default(IToken);
		AstParserRuleReturnScope<object, IToken> single_value93 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> single_value94 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> single_value96 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> single_value98 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr101 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> single_value105 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> single_value107 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal95_tree = default(object);
		object char_literal97_tree = default(object);
		object EVAL99_tree = default(object);
		object char_literal100_tree = default(object);
		object char_literal102_tree = default(object);
		object LIST103_tree = default(object);
		object char_literal104_tree = default(object);
		object char_literal106_tree = default(object);
		object char_literal108_tree = default(object);
		object LIST109_tree = default(object);
		object char_literal110_tree = default(object);
		object char_literal111_tree = default(object);
		RewriteRuleITokenStream stream_119=new RewriteRuleITokenStream(adaptor,"token 119");
		RewriteRuleITokenStream stream_EVAL=new RewriteRuleITokenStream(adaptor,"token EVAL");
		RewriteRuleITokenStream stream_117=new RewriteRuleITokenStream(adaptor,"token 117");
		RewriteRuleITokenStream stream_118=new RewriteRuleITokenStream(adaptor,"token 118");
		RewriteRuleITokenStream stream_LIST=new RewriteRuleITokenStream(adaptor,"token LIST");
		RewriteRuleSubtreeStream stream_single_value=new RewriteRuleSubtreeStream(adaptor,"rule single_value");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "declaration_value");
		DebugLocation(689, 1);
		try
		{
			// MapCSS.g:690:2: ( single_value | single_value ',' single_value ( ',' single_value )* -> ^( VALUE_LIST ( single_value )* ) | EVAL '(' expr ')' -> ^( EVAL_CALL expr ) | LIST '(' single_value ( ',' single_value )* ')' -> ^( VALUE_LIST ( single_value )* ) | LIST '(' ')' -> ^( VALUE_LIST ) )
			int alt28=5;
			try { DebugEnterDecision(28, false);
			switch (input.LA(1))
			{
			case POSITIVE_INT:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NEGATIVE_INT:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case POSITIVE_FLOAT:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NEGATIVE_FLOAT:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INCREMENT:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case POINTS:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case PIXELS:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case PERCENTAGE:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case URL:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case RGB:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==117))
				{
					int LA28_3 = input.LA(3);

					if ((LA28_3==POSITIVE_INT))
					{
						int LA28_4 = input.LA(4);

						if ((LA28_4==119))
						{
							int LA28_5 = input.LA(5);

							if ((LA28_5==POSITIVE_INT))
							{
								int LA28_6 = input.LA(6);

								if ((LA28_6==119))
								{
									int LA28_7 = input.LA(7);

									if ((LA28_7==POSITIVE_INT))
									{
										int LA28_8 = input.LA(8);

										if ((LA28_8==118))
										{
											int LA28_9 = input.LA(9);

											if ((LA28_9==RBRACE||LA28_9==SEMICOLON))
											{
												alt28 = 1;
											}
											else if ((LA28_9==119))
											{
												alt28 = 2;
											}
											else
											{
												if (state.backtracking>0) {state.failed=true; return retval;}
												NoViableAltException nvae = new NoViableAltException("", 28, 36, input, 9);
												DebugRecognitionException(nvae);
												throw nvae;
											}
										}
										else
										{
											if (state.backtracking>0) {state.failed=true; return retval;}
											NoViableAltException nvae = new NoViableAltException("", 28, 34, input, 8);
											DebugRecognitionException(nvae);
											throw nvae;
										}
									}
									else
									{
										if (state.backtracking>0) {state.failed=true; return retval;}
										NoViableAltException nvae = new NoViableAltException("", 28, 32, input, 7);
										DebugRecognitionException(nvae);
										throw nvae;
									}
								}
								else
								{
									if (state.backtracking>0) {state.failed=true; return retval;}
									NoViableAltException nvae = new NoViableAltException("", 28, 30, input, 6);
									DebugRecognitionException(nvae);
									throw nvae;
								}
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 28, 28, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 28, 24, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 28, 21, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case RGBA:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==117))
				{
					int LA28_3 = input.LA(3);

					if ((LA28_3==POSITIVE_INT))
					{
						int LA28_4 = input.LA(4);

						if ((LA28_4==119))
						{
							int LA28_5 = input.LA(5);

							if ((LA28_5==POSITIVE_INT))
							{
								int LA28_6 = input.LA(6);

								if ((LA28_6==119))
								{
									int LA28_7 = input.LA(7);

									if ((LA28_7==POSITIVE_INT))
									{
										int LA28_8 = input.LA(8);

										if ((LA28_8==119))
										{
											switch (input.LA(9))
											{
											case POSITIVE_INT:
												{
												int LA28_10 = input.LA(10);

												if ((LA28_10==118))
												{
													int LA28_11 = input.LA(11);

													if ((LA28_11==RBRACE||LA28_11==SEMICOLON))
													{
														alt28 = 1;
													}
													else if ((LA28_11==119))
													{
														alt28 = 2;
													}
													else
													{
														if (state.backtracking>0) {state.failed=true; return retval;}
														NoViableAltException nvae = new NoViableAltException("", 28, 42, input, 11);
														DebugRecognitionException(nvae);
														throw nvae;
													}
												}
												else
												{
													if (state.backtracking>0) {state.failed=true; return retval;}
													NoViableAltException nvae = new NoViableAltException("", 28, 38, input, 10);
													DebugRecognitionException(nvae);
													throw nvae;
												}
												}
												break;
											case NEGATIVE_INT:
												{
												int LA28_10 = input.LA(10);

												if ((LA28_10==118))
												{
													int LA28_11 = input.LA(11);

													if ((LA28_11==RBRACE||LA28_11==SEMICOLON))
													{
														alt28 = 1;
													}
													else if ((LA28_11==119))
													{
														alt28 = 2;
													}
													else
													{
														if (state.backtracking>0) {state.failed=true; return retval;}
														NoViableAltException nvae = new NoViableAltException("", 28, 42, input, 11);
														DebugRecognitionException(nvae);
														throw nvae;
													}
												}
												else
												{
													if (state.backtracking>0) {state.failed=true; return retval;}
													NoViableAltException nvae = new NoViableAltException("", 28, 39, input, 10);
													DebugRecognitionException(nvae);
													throw nvae;
												}
												}
												break;
											case POSITIVE_FLOAT:
												{
												int LA28_10 = input.LA(10);

												if ((LA28_10==118))
												{
													int LA28_11 = input.LA(11);

													if ((LA28_11==RBRACE||LA28_11==SEMICOLON))
													{
														alt28 = 1;
													}
													else if ((LA28_11==119))
													{
														alt28 = 2;
													}
													else
													{
														if (state.backtracking>0) {state.failed=true; return retval;}
														NoViableAltException nvae = new NoViableAltException("", 28, 42, input, 11);
														DebugRecognitionException(nvae);
														throw nvae;
													}
												}
												else
												{
													if (state.backtracking>0) {state.failed=true; return retval;}
													NoViableAltException nvae = new NoViableAltException("", 28, 40, input, 10);
													DebugRecognitionException(nvae);
													throw nvae;
												}
												}
												break;
											case NEGATIVE_FLOAT:
												{
												int LA28_10 = input.LA(10);

												if ((LA28_10==118))
												{
													int LA28_11 = input.LA(11);

													if ((LA28_11==RBRACE||LA28_11==SEMICOLON))
													{
														alt28 = 1;
													}
													else if ((LA28_11==119))
													{
														alt28 = 2;
													}
													else
													{
														if (state.backtracking>0) {state.failed=true; return retval;}
														NoViableAltException nvae = new NoViableAltException("", 28, 42, input, 11);
														DebugRecognitionException(nvae);
														throw nvae;
													}
												}
												else
												{
													if (state.backtracking>0) {state.failed=true; return retval;}
													NoViableAltException nvae = new NoViableAltException("", 28, 41, input, 10);
													DebugRecognitionException(nvae);
													throw nvae;
												}
												}
												break;
											default:
												{
													if (state.backtracking>0) {state.failed=true; return retval;}
													NoViableAltException nvae = new NoViableAltException("", 28, 37, input, 9);
													DebugRecognitionException(nvae);
													throw nvae;
												}
											}

										}
										else
										{
											if (state.backtracking>0) {state.failed=true; return retval;}
											NoViableAltException nvae = new NoViableAltException("", 28, 35, input, 8);
											DebugRecognitionException(nvae);
											throw nvae;
										}
									}
									else
									{
										if (state.backtracking>0) {state.failed=true; return retval;}
										NoViableAltException nvae = new NoViableAltException("", 28, 33, input, 7);
										DebugRecognitionException(nvae);
										throw nvae;
									}
								}
								else
								{
									if (state.backtracking>0) {state.failed=true; return retval;}
									NoViableAltException nvae = new NoViableAltException("", 28, 31, input, 6);
									DebugRecognitionException(nvae);
									throw nvae;
								}
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 28, 29, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 28, 25, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 28, 22, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 11, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case HEXCOLOR:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case DQUOTED_STRING:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 13, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case SQUOTED_STRING:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 14, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case OSM_TAG:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 15, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CSS_IDENT:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==RBRACE||LA28_2==SEMICOLON))
				{
					alt28 = 1;
				}
				else if ((LA28_2==119))
				{
					alt28 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 16, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case EVAL:
				{
				alt28 = 3;
				}
				break;
			case LIST:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==117))
				{
					int LA28_3 = input.LA(3);

					if ((LA28_3==118))
					{
						alt28 = 5;
					}
					else if ((LA28_3==CSS_IDENT||LA28_3==DQUOTED_STRING||LA28_3==HEXCOLOR||LA28_3==INCREMENT||(LA28_3>=NEGATIVE_FLOAT && LA28_3<=NEGATIVE_INT)||LA28_3==OSM_TAG||(LA28_3>=PERCENTAGE && LA28_3<=POSITIVE_INT)||(LA28_3>=RGB && LA28_3<=RGBA)||LA28_3==SQUOTED_STRING||LA28_3==URL))
					{
						alt28 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 28, 23, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 18, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:690:4: single_value
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(690, 4);
				PushFollow(Follow._single_value_in_declaration_value3971);
				single_value93=single_value();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, single_value93.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:691:4: single_value ',' single_value ( ',' single_value )*
				{
				DebugLocation(691, 4);
				PushFollow(Follow._single_value_in_declaration_value3976);
				single_value94=single_value();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_single_value.Add(single_value94.Tree);
				DebugLocation(691, 18);
				char_literal95=(IToken)Match(input,119,Follow._119_in_declaration_value3979); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_119.Add(char_literal95);

				DebugLocation(691, 22);
				PushFollow(Follow._single_value_in_declaration_value3981);
				single_value96=single_value();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_single_value.Add(single_value96.Tree);
				DebugLocation(691, 35);
				// MapCSS.g:691:35: ( ',' single_value )*
				try { DebugEnterSubRule(26);
				while (true)
				{
					int alt26=2;
					try { DebugEnterDecision(26, false);
					int LA26_1 = input.LA(1);

					if ((LA26_1==119))
					{
						alt26 = 1;
					}


					} finally { DebugExitDecision(26); }
					switch ( alt26 )
					{
					case 1:
						DebugEnterAlt(1);
						// MapCSS.g:691:36: ',' single_value
						{
						DebugLocation(691, 36);
						char_literal97=(IToken)Match(input,119,Follow._119_in_declaration_value3984); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_119.Add(char_literal97);

						DebugLocation(691, 40);
						PushFollow(Follow._single_value_in_declaration_value3986);
						single_value98=single_value();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_single_value.Add(single_value98.Tree);

						}
						break;

					default:
						goto loop26;
					}
				}

				loop26:
					;

				} finally { DebugExitSubRule(26); }



				{
				// AST REWRITE
				// elements: single_value
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 691:55: -> ^( VALUE_LIST ( single_value )* )
				{
					DebugLocation(691, 58);
					// MapCSS.g:691:58: ^( VALUE_LIST ( single_value )* )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(691, 60);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VALUE_LIST, "VALUE_LIST"), root_1);

					DebugLocation(691, 71);
					// MapCSS.g:691:71: ( single_value )*
					while ( stream_single_value.HasNext )
					{
						DebugLocation(691, 71);
						adaptor.AddChild(root_1, stream_single_value.NextTree());

					}
					stream_single_value.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:692:4: EVAL '(' expr ')'
				{
				DebugLocation(692, 4);
				EVAL99=(IToken)Match(input,EVAL,Follow._EVAL_in_declaration_value4002); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_EVAL.Add(EVAL99);

				DebugLocation(692, 10);
				char_literal100=(IToken)Match(input,117,Follow._117_in_declaration_value4005); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_117.Add(char_literal100);

				DebugLocation(692, 14);
				PushFollow(Follow._expr_in_declaration_value4007);
				expr101=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr101.Tree);
				DebugLocation(692, 19);
				char_literal102=(IToken)Match(input,118,Follow._118_in_declaration_value4009); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_118.Add(char_literal102);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 692:24: -> ^( EVAL_CALL expr )
				{
					DebugLocation(692, 27);
					// MapCSS.g:692:27: ^( EVAL_CALL expr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(692, 29);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EVAL_CALL, "EVAL_CALL"), root_1);

					DebugLocation(692, 39);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// MapCSS.g:693:4: LIST '(' single_value ( ',' single_value )* ')'
				{
				DebugLocation(693, 4);
				LIST103=(IToken)Match(input,LIST,Follow._LIST_in_declaration_value4024); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LIST.Add(LIST103);

				DebugLocation(693, 10);
				char_literal104=(IToken)Match(input,117,Follow._117_in_declaration_value4027); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_117.Add(char_literal104);

				DebugLocation(693, 14);
				PushFollow(Follow._single_value_in_declaration_value4029);
				single_value105=single_value();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_single_value.Add(single_value105.Tree);
				DebugLocation(693, 27);
				// MapCSS.g:693:27: ( ',' single_value )*
				try { DebugEnterSubRule(27);
				while (true)
				{
					int alt27=2;
					try { DebugEnterDecision(27, false);
					int LA27_1 = input.LA(1);

					if ((LA27_1==119))
					{
						alt27 = 1;
					}


					} finally { DebugExitDecision(27); }
					switch ( alt27 )
					{
					case 1:
						DebugEnterAlt(1);
						// MapCSS.g:693:28: ',' single_value
						{
						DebugLocation(693, 28);
						char_literal106=(IToken)Match(input,119,Follow._119_in_declaration_value4032); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_119.Add(char_literal106);

						DebugLocation(693, 32);
						PushFollow(Follow._single_value_in_declaration_value4034);
						single_value107=single_value();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_single_value.Add(single_value107.Tree);

						}
						break;

					default:
						goto loop27;
					}
				}

				loop27:
					;

				} finally { DebugExitSubRule(27); }

				DebugLocation(693, 47);
				char_literal108=(IToken)Match(input,118,Follow._118_in_declaration_value4038); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_118.Add(char_literal108);



				{
				// AST REWRITE
				// elements: single_value
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 693:51: -> ^( VALUE_LIST ( single_value )* )
				{
					DebugLocation(693, 55);
					// MapCSS.g:693:55: ^( VALUE_LIST ( single_value )* )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(693, 57);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VALUE_LIST, "VALUE_LIST"), root_1);

					DebugLocation(693, 68);
					// MapCSS.g:693:68: ( single_value )*
					while ( stream_single_value.HasNext )
					{
						DebugLocation(693, 68);
						adaptor.AddChild(root_1, stream_single_value.NextTree());

					}
					stream_single_value.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// MapCSS.g:694:4: LIST '(' ')'
				{
				DebugLocation(694, 4);
				LIST109=(IToken)Match(input,LIST,Follow._LIST_in_declaration_value4054); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LIST.Add(LIST109);

				DebugLocation(694, 10);
				char_literal110=(IToken)Match(input,117,Follow._117_in_declaration_value4057); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_117.Add(char_literal110);

				DebugLocation(694, 14);
				char_literal111=(IToken)Match(input,118,Follow._118_in_declaration_value4059); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_118.Add(char_literal111);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 694:18: -> ^( VALUE_LIST )
				{
					DebugLocation(694, 21);
					// MapCSS.g:694:21: ^( VALUE_LIST )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(694, 23);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VALUE_LIST, "VALUE_LIST"), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration_value", 28);
			LeaveRule("declaration_value", 28);
			LeaveRule_declaration_value();
		}
		DebugLocation(695, 1);
		} finally { DebugExitRule(GrammarFileName, "declaration_value"); }
		return retval;

	}
	// $ANTLR end "declaration_value"

	partial void EnterRule_num();
	partial void LeaveRule_num();
	// $ANTLR start "num"
	// MapCSS.g:698:1: num : (n= POSITIVE_INT -> VALUE_INT[$n] |n= NEGATIVE_INT -> VALUE_INT[$n] |n= POSITIVE_FLOAT -> VALUE_FLOAT[$n] |n= NEGATIVE_FLOAT -> VALUE_FLOAT[$n] );
	[GrammarRule("num")]
	private AstParserRuleReturnScope<object, IToken> num()
	{
		EnterRule_num();
		EnterRule("num", 29);
		TraceIn("num", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken n = default(IToken);

		object n_tree = default(object);
		RewriteRuleITokenStream stream_POSITIVE_INT=new RewriteRuleITokenStream(adaptor,"token POSITIVE_INT");
		RewriteRuleITokenStream stream_NEGATIVE_INT=new RewriteRuleITokenStream(adaptor,"token NEGATIVE_INT");
		RewriteRuleITokenStream stream_POSITIVE_FLOAT=new RewriteRuleITokenStream(adaptor,"token POSITIVE_FLOAT");
		RewriteRuleITokenStream stream_NEGATIVE_FLOAT=new RewriteRuleITokenStream(adaptor,"token NEGATIVE_FLOAT");
		try { DebugEnterRule(GrammarFileName, "num");
		DebugLocation(698, 1);
		try
		{
			// MapCSS.g:699:2: (n= POSITIVE_INT -> VALUE_INT[$n] |n= NEGATIVE_INT -> VALUE_INT[$n] |n= POSITIVE_FLOAT -> VALUE_FLOAT[$n] |n= NEGATIVE_FLOAT -> VALUE_FLOAT[$n] )
			int alt29=4;
			try { DebugEnterDecision(29, false);
			switch (input.LA(1))
			{
			case POSITIVE_INT:
				{
				alt29 = 1;
				}
				break;
			case NEGATIVE_INT:
				{
				alt29 = 2;
				}
				break;
			case POSITIVE_FLOAT:
				{
				alt29 = 3;
				}
				break;
			case NEGATIVE_FLOAT:
				{
				alt29 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 29, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:699:4: n= POSITIVE_INT
				{
				DebugLocation(699, 5);
				n=(IToken)Match(input,POSITIVE_INT,Follow._POSITIVE_INT_in_num4080); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_INT.Add(n);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 699:25: -> VALUE_INT[$n]
				{
					DebugLocation(699, 30);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_INT, n));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:700:4: n= NEGATIVE_INT
				{
				DebugLocation(700, 5);
				n=(IToken)Match(input,NEGATIVE_INT,Follow._NEGATIVE_INT_in_num4100); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NEGATIVE_INT.Add(n);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 700:25: -> VALUE_INT[$n]
				{
					DebugLocation(700, 30);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_INT, n));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:701:4: n= POSITIVE_FLOAT
				{
				DebugLocation(701, 5);
				n=(IToken)Match(input,POSITIVE_FLOAT,Follow._POSITIVE_FLOAT_in_num4120); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_FLOAT.Add(n);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 701:25: -> VALUE_FLOAT[$n]
				{
					DebugLocation(701, 30);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_FLOAT, n));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// MapCSS.g:702:4: n= NEGATIVE_FLOAT
				{
				DebugLocation(702, 5);
				n=(IToken)Match(input,NEGATIVE_FLOAT,Follow._NEGATIVE_FLOAT_in_num4138); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NEGATIVE_FLOAT.Add(n);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 702:25: -> VALUE_FLOAT[$n]
				{
					DebugLocation(702, 30);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_FLOAT, n));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("num", 29);
			LeaveRule("num", 29);
			LeaveRule_num();
		}
		DebugLocation(703, 1);
		} finally { DebugExitRule(GrammarFileName, "num"); }
		return retval;

	}
	// $ANTLR end "num"

	partial void EnterRule_single_value();
	partial void LeaveRule_single_value();
	// $ANTLR start "single_value"
	// MapCSS.g:705:1: single_value : (v= POSITIVE_INT -> VALUE_INT[$v] |v= NEGATIVE_INT -> VALUE_INT[$v] |v= POSITIVE_FLOAT -> VALUE_FLOAT[$v] |v= NEGATIVE_FLOAT -> VALUE_FLOAT[$v] |v= INCREMENT -> VALUE_INCREMENT[$v] |v= POINTS -> VALUE_POINTS[$v] |v= PIXELS -> VALUE_PIXELS[$v] |v= PERCENTAGE -> VALUE_PERCENTAGE[$v] | URL -> VALUE_URL[_extractUrl($URL)] | RGB '(' r= POSITIVE_INT ',' g= POSITIVE_INT ',' b= POSITIVE_INT ')' -> ^( VALUE_RGB VALUE_INT[$r] VALUE_INT[$g] VALUE_INT[$b] ) | RGBA '(' r= POSITIVE_INT ',' g= POSITIVE_INT ',' b= POSITIVE_INT ',' a= num ')' -> ^( VALUE_RGBA VALUE_INT[$r] VALUE_INT[$g] VALUE_INT[$b] VALUE_FLOAT[$a.text] ) |c= HEXCOLOR -> ^( VALUE_RGB VALUE_INT[_red(c)] VALUE_INT[_green(c)] VALUE_INT[_blue(c)] ) | quoted -> VALUE_QUOTED[$quoted.text] |k= OSM_TAG -> VALUE_KEYWORD[$k] | cssident );
	[GrammarRule("single_value")]
	private AstParserRuleReturnScope<object, IToken> single_value()
	{
		EnterRule_single_value();
		EnterRule("single_value", 30);
		TraceIn("single_value", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken v = default(IToken);
		IToken r = default(IToken);
		IToken g = default(IToken);
		IToken b = default(IToken);
		IToken c = default(IToken);
		IToken k = default(IToken);
		IToken URL112 = default(IToken);
		IToken RGB113 = default(IToken);
		IToken char_literal114 = default(IToken);
		IToken char_literal115 = default(IToken);
		IToken char_literal116 = default(IToken);
		IToken char_literal117 = default(IToken);
		IToken RGBA118 = default(IToken);
		IToken char_literal119 = default(IToken);
		IToken char_literal120 = default(IToken);
		IToken char_literal121 = default(IToken);
		IToken char_literal122 = default(IToken);
		IToken char_literal123 = default(IToken);
		AstParserRuleReturnScope<object, IToken> a = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> quoted124 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> cssident125 = default(AstParserRuleReturnScope<object, IToken>);

		object v_tree = default(object);
		object r_tree = default(object);
		object g_tree = default(object);
		object b_tree = default(object);
		object c_tree = default(object);
		object k_tree = default(object);
		object URL112_tree = default(object);
		object RGB113_tree = default(object);
		object char_literal114_tree = default(object);
		object char_literal115_tree = default(object);
		object char_literal116_tree = default(object);
		object char_literal117_tree = default(object);
		object RGBA118_tree = default(object);
		object char_literal119_tree = default(object);
		object char_literal120_tree = default(object);
		object char_literal121_tree = default(object);
		object char_literal122_tree = default(object);
		object char_literal123_tree = default(object);
		RewriteRuleITokenStream stream_POSITIVE_INT=new RewriteRuleITokenStream(adaptor,"token POSITIVE_INT");
		RewriteRuleITokenStream stream_NEGATIVE_INT=new RewriteRuleITokenStream(adaptor,"token NEGATIVE_INT");
		RewriteRuleITokenStream stream_POSITIVE_FLOAT=new RewriteRuleITokenStream(adaptor,"token POSITIVE_FLOAT");
		RewriteRuleITokenStream stream_NEGATIVE_FLOAT=new RewriteRuleITokenStream(adaptor,"token NEGATIVE_FLOAT");
		RewriteRuleITokenStream stream_INCREMENT=new RewriteRuleITokenStream(adaptor,"token INCREMENT");
		RewriteRuleITokenStream stream_POINTS=new RewriteRuleITokenStream(adaptor,"token POINTS");
		RewriteRuleITokenStream stream_PIXELS=new RewriteRuleITokenStream(adaptor,"token PIXELS");
		RewriteRuleITokenStream stream_PERCENTAGE=new RewriteRuleITokenStream(adaptor,"token PERCENTAGE");
		RewriteRuleITokenStream stream_URL=new RewriteRuleITokenStream(adaptor,"token URL");
		RewriteRuleITokenStream stream_RGB=new RewriteRuleITokenStream(adaptor,"token RGB");
		RewriteRuleITokenStream stream_117=new RewriteRuleITokenStream(adaptor,"token 117");
		RewriteRuleITokenStream stream_119=new RewriteRuleITokenStream(adaptor,"token 119");
		RewriteRuleITokenStream stream_118=new RewriteRuleITokenStream(adaptor,"token 118");
		RewriteRuleITokenStream stream_RGBA=new RewriteRuleITokenStream(adaptor,"token RGBA");
		RewriteRuleITokenStream stream_HEXCOLOR=new RewriteRuleITokenStream(adaptor,"token HEXCOLOR");
		RewriteRuleITokenStream stream_OSM_TAG=new RewriteRuleITokenStream(adaptor,"token OSM_TAG");
		RewriteRuleSubtreeStream stream_num=new RewriteRuleSubtreeStream(adaptor,"rule num");
		RewriteRuleSubtreeStream stream_quoted=new RewriteRuleSubtreeStream(adaptor,"rule quoted");
		try { DebugEnterRule(GrammarFileName, "single_value");
		DebugLocation(705, 1);
		try
		{
			// MapCSS.g:706:2: (v= POSITIVE_INT -> VALUE_INT[$v] |v= NEGATIVE_INT -> VALUE_INT[$v] |v= POSITIVE_FLOAT -> VALUE_FLOAT[$v] |v= NEGATIVE_FLOAT -> VALUE_FLOAT[$v] |v= INCREMENT -> VALUE_INCREMENT[$v] |v= POINTS -> VALUE_POINTS[$v] |v= PIXELS -> VALUE_PIXELS[$v] |v= PERCENTAGE -> VALUE_PERCENTAGE[$v] | URL -> VALUE_URL[_extractUrl($URL)] | RGB '(' r= POSITIVE_INT ',' g= POSITIVE_INT ',' b= POSITIVE_INT ')' -> ^( VALUE_RGB VALUE_INT[$r] VALUE_INT[$g] VALUE_INT[$b] ) | RGBA '(' r= POSITIVE_INT ',' g= POSITIVE_INT ',' b= POSITIVE_INT ',' a= num ')' -> ^( VALUE_RGBA VALUE_INT[$r] VALUE_INT[$g] VALUE_INT[$b] VALUE_FLOAT[$a.text] ) |c= HEXCOLOR -> ^( VALUE_RGB VALUE_INT[_red(c)] VALUE_INT[_green(c)] VALUE_INT[_blue(c)] ) | quoted -> VALUE_QUOTED[$quoted.text] |k= OSM_TAG -> VALUE_KEYWORD[$k] | cssident )
			int alt30=15;
			try { DebugEnterDecision(30, false);
			switch (input.LA(1))
			{
			case POSITIVE_INT:
				{
				alt30 = 1;
				}
				break;
			case NEGATIVE_INT:
				{
				alt30 = 2;
				}
				break;
			case POSITIVE_FLOAT:
				{
				alt30 = 3;
				}
				break;
			case NEGATIVE_FLOAT:
				{
				alt30 = 4;
				}
				break;
			case INCREMENT:
				{
				alt30 = 5;
				}
				break;
			case POINTS:
				{
				alt30 = 6;
				}
				break;
			case PIXELS:
				{
				alt30 = 7;
				}
				break;
			case PERCENTAGE:
				{
				alt30 = 8;
				}
				break;
			case URL:
				{
				alt30 = 9;
				}
				break;
			case RGB:
				{
				alt30 = 10;
				}
				break;
			case RGBA:
				{
				alt30 = 11;
				}
				break;
			case HEXCOLOR:
				{
				alt30 = 12;
				}
				break;
			case DQUOTED_STRING:
			case SQUOTED_STRING:
				{
				alt30 = 13;
				}
				break;
			case OSM_TAG:
				{
				alt30 = 14;
				}
				break;
			case CSS_IDENT:
				{
				alt30 = 15;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 30, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:706:4: v= POSITIVE_INT
				{
				DebugLocation(706, 5);
				v=(IToken)Match(input,POSITIVE_INT,Follow._POSITIVE_INT_in_single_value4163); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_INT.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 706:30: -> VALUE_INT[$v]
				{
					DebugLocation(706, 33);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_INT, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:707:4: v= NEGATIVE_INT
				{
				DebugLocation(707, 5);
				v=(IToken)Match(input,NEGATIVE_INT,Follow._NEGATIVE_INT_in_single_value4186); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NEGATIVE_INT.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 707:30: -> VALUE_INT[$v]
				{
					DebugLocation(707, 33);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_INT, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:708:4: v= POSITIVE_FLOAT
				{
				DebugLocation(708, 5);
				v=(IToken)Match(input,POSITIVE_FLOAT,Follow._POSITIVE_FLOAT_in_single_value4209); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_FLOAT.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 708:30: -> VALUE_FLOAT[$v]
				{
					DebugLocation(708, 33);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_FLOAT, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// MapCSS.g:709:4: v= NEGATIVE_FLOAT
				{
				DebugLocation(709, 5);
				v=(IToken)Match(input,NEGATIVE_FLOAT,Follow._NEGATIVE_FLOAT_in_single_value4230); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NEGATIVE_FLOAT.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 709:30: -> VALUE_FLOAT[$v]
				{
					DebugLocation(709, 33);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_FLOAT, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// MapCSS.g:710:4: v= INCREMENT
				{
				DebugLocation(710, 5);
				v=(IToken)Match(input,INCREMENT,Follow._INCREMENT_in_single_value4252); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INCREMENT.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 710:30: -> VALUE_INCREMENT[$v]
				{
					DebugLocation(710, 33);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_INCREMENT, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// MapCSS.g:711:4: v= POINTS
				{
				DebugLocation(711, 5);
				v=(IToken)Match(input,POINTS,Follow._POINTS_in_single_value4278); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POINTS.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 711:18: -> VALUE_POINTS[$v]
				{
					DebugLocation(711, 21);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_POINTS, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// MapCSS.g:712:4: v= PIXELS
				{
				DebugLocation(712, 5);
				v=(IToken)Match(input,PIXELS,Follow._PIXELS_in_single_value4295); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PIXELS.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 712:21: -> VALUE_PIXELS[$v]
				{
					DebugLocation(712, 24);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_PIXELS, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// MapCSS.g:713:4: v= PERCENTAGE
				{
				DebugLocation(713, 5);
				v=(IToken)Match(input,PERCENTAGE,Follow._PERCENTAGE_in_single_value4315); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PERCENTAGE.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 713:21: -> VALUE_PERCENTAGE[$v]
				{
					DebugLocation(713, 24);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_PERCENTAGE, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// MapCSS.g:714:4: URL
				{
				DebugLocation(714, 4);
				URL112=(IToken)Match(input,URL,Follow._URL_in_single_value4330); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_URL.Add(URL112);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 714:10: -> VALUE_URL[_extractUrl($URL)]
				{
					DebugLocation(714, 13);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_URL, _extractUrl(URL112)));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// MapCSS.g:715:7: RGB '(' r= POSITIVE_INT ',' g= POSITIVE_INT ',' b= POSITIVE_INT ')'
				{
				DebugLocation(715, 7);
				RGB113=(IToken)Match(input,RGB,Follow._RGB_in_single_value4345); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RGB.Add(RGB113);

				DebugLocation(715, 11);
				char_literal114=(IToken)Match(input,117,Follow._117_in_single_value4347); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_117.Add(char_literal114);

				DebugLocation(715, 16);
				r=(IToken)Match(input,POSITIVE_INT,Follow._POSITIVE_INT_in_single_value4351); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_INT.Add(r);

				DebugLocation(715, 30);
				char_literal115=(IToken)Match(input,119,Follow._119_in_single_value4353); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_119.Add(char_literal115);

				DebugLocation(715, 35);
				g=(IToken)Match(input,POSITIVE_INT,Follow._POSITIVE_INT_in_single_value4357); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_INT.Add(g);

				DebugLocation(715, 49);
				char_literal116=(IToken)Match(input,119,Follow._119_in_single_value4359); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_119.Add(char_literal116);

				DebugLocation(715, 54);
				b=(IToken)Match(input,POSITIVE_INT,Follow._POSITIVE_INT_in_single_value4363); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_INT.Add(b);

				DebugLocation(715, 68);
				char_literal117=(IToken)Match(input,118,Follow._118_in_single_value4365); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_118.Add(char_literal117);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 716:11: -> ^( VALUE_RGB VALUE_INT[$r] VALUE_INT[$g] VALUE_INT[$b] )
				{
					DebugLocation(716, 14);
					// MapCSS.g:716:14: ^( VALUE_RGB VALUE_INT[$r] VALUE_INT[$g] VALUE_INT[$b] )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(716, 16);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VALUE_RGB, "VALUE_RGB"), root_1);

					DebugLocation(716, 26);
					adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_INT, r));
					DebugLocation(716, 40);
					adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_INT, g));
					DebugLocation(716, 54);
					adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_INT, b));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// MapCSS.g:717:4: RGBA '(' r= POSITIVE_INT ',' g= POSITIVE_INT ',' b= POSITIVE_INT ',' a= num ')'
				{
				DebugLocation(717, 4);
				RGBA118=(IToken)Match(input,RGBA,Follow._RGBA_in_single_value4408); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RGBA.Add(RGBA118);

				DebugLocation(717, 9);
				char_literal119=(IToken)Match(input,117,Follow._117_in_single_value4410); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_117.Add(char_literal119);

				DebugLocation(717, 14);
				r=(IToken)Match(input,POSITIVE_INT,Follow._POSITIVE_INT_in_single_value4414); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_INT.Add(r);

				DebugLocation(717, 28);
				char_literal120=(IToken)Match(input,119,Follow._119_in_single_value4416); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_119.Add(char_literal120);

				DebugLocation(717, 33);
				g=(IToken)Match(input,POSITIVE_INT,Follow._POSITIVE_INT_in_single_value4420); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_INT.Add(g);

				DebugLocation(717, 47);
				char_literal121=(IToken)Match(input,119,Follow._119_in_single_value4422); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_119.Add(char_literal121);

				DebugLocation(717, 52);
				b=(IToken)Match(input,POSITIVE_INT,Follow._POSITIVE_INT_in_single_value4426); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_INT.Add(b);

				DebugLocation(717, 66);
				char_literal122=(IToken)Match(input,119,Follow._119_in_single_value4428); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_119.Add(char_literal122);

				DebugLocation(717, 71);
				PushFollow(Follow._num_in_single_value4432);
				a=num();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_num.Add(a.Tree);
				DebugLocation(717, 76);
				char_literal123=(IToken)Match(input,118,Follow._118_in_single_value4434); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_118.Add(char_literal123);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 718:11: -> ^( VALUE_RGBA VALUE_INT[$r] VALUE_INT[$g] VALUE_INT[$b] VALUE_FLOAT[$a.text] )
				{
					DebugLocation(718, 14);
					// MapCSS.g:718:14: ^( VALUE_RGBA VALUE_INT[$r] VALUE_INT[$g] VALUE_INT[$b] VALUE_FLOAT[$a.text] )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(718, 16);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VALUE_RGBA, "VALUE_RGBA"), root_1);

					DebugLocation(718, 27);
					adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_INT, r));
					DebugLocation(718, 41);
					adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_INT, g));
					DebugLocation(718, 55);
					adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_INT, b));
					DebugLocation(718, 69);
					adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_FLOAT, (a!=null?input.ToString(a.Start,a.Stop):default(string))));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// MapCSS.g:719:4: c= HEXCOLOR
				{
				DebugLocation(719, 5);
				c=(IToken)Match(input,HEXCOLOR,Follow._HEXCOLOR_in_single_value4469); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_HEXCOLOR.Add(c);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 719:20: -> ^( VALUE_RGB VALUE_INT[_red(c)] VALUE_INT[_green(c)] VALUE_INT[_blue(c)] )
				{
					DebugLocation(719, 23);
					// MapCSS.g:719:23: ^( VALUE_RGB VALUE_INT[_red(c)] VALUE_INT[_green(c)] VALUE_INT[_blue(c)] )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(719, 25);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VALUE_RGB, "VALUE_RGB"), root_1);

					DebugLocation(719, 35);
					adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_INT, _red(c)));
					DebugLocation(719, 54);
					adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_INT, _green(c)));
					DebugLocation(719, 75);
					adaptor.AddChild(root_1, (object)adaptor.Create(VALUE_INT, _blue(c)));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// MapCSS.g:720:4: quoted
				{
				DebugLocation(720, 4);
				PushFollow(Follow._quoted_in_single_value4494);
				quoted124=quoted();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_quoted.Add(quoted124.Tree);


				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 720:21: -> VALUE_QUOTED[$quoted.text]
				{
					DebugLocation(720, 24);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_QUOTED, (quoted124!=null?input.ToString(quoted124.Start,quoted124.Stop):default(string))));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// MapCSS.g:723:7: k= OSM_TAG
				{
				DebugLocation(723, 8);
				k=(IToken)Match(input,OSM_TAG,Follow._OSM_TAG_in_single_value4526); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OSM_TAG.Add(k);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 723:28: -> VALUE_KEYWORD[$k]
				{
					DebugLocation(723, 31);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_KEYWORD, k));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// MapCSS.g:724:7: cssident
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(724, 7);
				PushFollow(Follow._cssident_in_single_value4556);
				cssident125=cssident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, cssident125.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("single_value", 30);
			LeaveRule("single_value", 30);
			LeaveRule_single_value();
		}
		DebugLocation(725, 1);
		} finally { DebugExitRule(GrammarFileName, "single_value"); }
		return retval;

	}
	// $ANTLR end "single_value"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();
	// $ANTLR start "expr"
	// MapCSS.g:730:1: expr : logicalExpression ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<object, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 31);
		TraceIn("expr", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> logicalExpression126 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(730, 1);
		try
		{
			// MapCSS.g:731:2: ( logicalExpression )
			DebugEnterAlt(1);
			// MapCSS.g:731:4: logicalExpression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(731, 4);
			PushFollow(Follow._logicalExpression_in_expr4577);
			logicalExpression126=logicalExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, logicalExpression126.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 31);
			LeaveRule("expr", 31);
			LeaveRule_expr();
		}
		DebugLocation(732, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_args();
	partial void LeaveRule_args();
	// $ANTLR start "args"
	// MapCSS.g:734:1: args : expr ( ',' expr )* -> ( expr )+ ;
	[GrammarRule("args")]
	private AstParserRuleReturnScope<object, IToken> args()
	{
		EnterRule_args();
		EnterRule("args", 32);
		TraceIn("args", 32);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal128 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr127 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr129 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal128_tree = default(object);
		RewriteRuleITokenStream stream_119=new RewriteRuleITokenStream(adaptor,"token 119");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "args");
		DebugLocation(734, 1);
		try
		{
			// MapCSS.g:735:2: ( expr ( ',' expr )* -> ( expr )+ )
			DebugEnterAlt(1);
			// MapCSS.g:735:4: expr ( ',' expr )*
			{
			DebugLocation(735, 4);
			PushFollow(Follow._expr_in_args4588);
			expr127=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr127.Tree);
			DebugLocation(735, 9);
			// MapCSS.g:735:9: ( ',' expr )*
			try { DebugEnterSubRule(31);
			while (true)
			{
				int alt31=2;
				try { DebugEnterDecision(31, false);
				int LA31_1 = input.LA(1);

				if ((LA31_1==119))
				{
					alt31 = 1;
				}


				} finally { DebugExitDecision(31); }
				switch ( alt31 )
				{
				case 1:
					DebugEnterAlt(1);
					// MapCSS.g:735:10: ',' expr
					{
					DebugLocation(735, 10);
					char_literal128=(IToken)Match(input,119,Follow._119_in_args4591); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_119.Add(char_literal128);

					DebugLocation(735, 14);
					PushFollow(Follow._expr_in_args4593);
					expr129=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr.Add(expr129.Tree);

					}
					break;

				default:
					goto loop31;
				}
			}

			loop31:
				;

			} finally { DebugExitSubRule(31); }



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 735:24: -> ( expr )+
			{
				DebugLocation(735, 28);
				if (!(stream_expr.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_expr.HasNext )
				{
					DebugLocation(735, 28);
					adaptor.AddChild(root_0, stream_expr.NextTree());

				}
				stream_expr.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("args", 32);
			LeaveRule("args", 32);
			LeaveRule_args();
		}
		DebugLocation(736, 1);
		} finally { DebugExitRule(GrammarFileName, "args"); }
		return retval;

	}
	// $ANTLR end "args"

	partial void EnterRule_logicalExpression();
	partial void LeaveRule_logicalExpression();
	// $ANTLR start "logicalExpression"
	// MapCSS.g:738:1: logicalExpression : booleanAndExpression ( ( OP_OR )=> OP_OR logicalExpression -> ^( OP_OR booleanAndExpression logicalExpression ) | -> booleanAndExpression ) ;
	[GrammarRule("logicalExpression")]
	private AstParserRuleReturnScope<object, IToken> logicalExpression()
	{
		EnterRule_logicalExpression();
		EnterRule("logicalExpression", 33);
		TraceIn("logicalExpression", 33);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OP_OR131 = default(IToken);
		AstParserRuleReturnScope<object, IToken> booleanAndExpression130 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logicalExpression132 = default(AstParserRuleReturnScope<object, IToken>);

		object OP_OR131_tree = default(object);
		RewriteRuleITokenStream stream_OP_OR=new RewriteRuleITokenStream(adaptor,"token OP_OR");
		RewriteRuleSubtreeStream stream_booleanAndExpression=new RewriteRuleSubtreeStream(adaptor,"rule booleanAndExpression");
		RewriteRuleSubtreeStream stream_logicalExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalExpression");
		try { DebugEnterRule(GrammarFileName, "logicalExpression");
		DebugLocation(738, 4);
		try
		{
			// MapCSS.g:739:5: ( booleanAndExpression ( ( OP_OR )=> OP_OR logicalExpression -> ^( OP_OR booleanAndExpression logicalExpression ) | -> booleanAndExpression ) )
			DebugEnterAlt(1);
			// MapCSS.g:739:10: booleanAndExpression ( ( OP_OR )=> OP_OR logicalExpression -> ^( OP_OR booleanAndExpression logicalExpression ) | -> booleanAndExpression )
			{
			DebugLocation(739, 10);
			PushFollow(Follow._booleanAndExpression_in_logicalExpression4622);
			booleanAndExpression130=booleanAndExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_booleanAndExpression.Add(booleanAndExpression130.Tree);
			DebugLocation(739, 31);
			// MapCSS.g:739:31: ( ( OP_OR )=> OP_OR logicalExpression -> ^( OP_OR booleanAndExpression logicalExpression ) | -> booleanAndExpression )
			int alt32=2;
			try { DebugEnterSubRule(32);
			try { DebugEnterDecision(32, false);
			int LA32_1 = input.LA(1);

			if ((LA32_1==OP_OR) && (EvaluatePredicate(synpred1_MapCSS_fragment)))
			{
				alt32 = 1;
			}
			else if (((LA32_1>=118 && LA32_1<=119)))
			{
				alt32 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 32, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:740:14: ( OP_OR )=> OP_OR logicalExpression
				{
				DebugLocation(740, 25);
				OP_OR131=(IToken)Match(input,OP_OR,Follow._OP_OR_in_logicalExpression4646); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_OR.Add(OP_OR131);

				DebugLocation(740, 31);
				PushFollow(Follow._logicalExpression_in_logicalExpression4648);
				logicalExpression132=logicalExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_logicalExpression.Add(logicalExpression132.Tree);


				{
				// AST REWRITE
				// elements: OP_OR, booleanAndExpression, logicalExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 740:49: -> ^( OP_OR booleanAndExpression logicalExpression )
				{
					DebugLocation(740, 52);
					// MapCSS.g:740:52: ^( OP_OR booleanAndExpression logicalExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(740, 54);
					root_1 = (object)adaptor.BecomeRoot(stream_OP_OR.NextNode(), root_1);

					DebugLocation(740, 60);
					adaptor.AddChild(root_1, stream_booleanAndExpression.NextTree());
					DebugLocation(740, 81);
					adaptor.AddChild(root_1, stream_logicalExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:741:45: 
				{

				{
				// AST REWRITE
				// elements: booleanAndExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 741:45: -> booleanAndExpression
				{
					DebugLocation(741, 48);
					adaptor.AddChild(root_0, stream_booleanAndExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(32); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalExpression", 33);
			LeaveRule("logicalExpression", 33);
			LeaveRule_logicalExpression();
		}
		DebugLocation(743, 4);
		} finally { DebugExitRule(GrammarFileName, "logicalExpression"); }
		return retval;

	}
	// $ANTLR end "logicalExpression"

	partial void EnterRule_booleanAndExpression();
	partial void LeaveRule_booleanAndExpression();
	// $ANTLR start "booleanAndExpression"
	// MapCSS.g:745:1: booleanAndExpression : equalityExpression ( ( OP_AND )=> OP_AND booleanAndExpression -> ^( OP_AND equalityExpression booleanAndExpression ) | -> equalityExpression ) ;
	[GrammarRule("booleanAndExpression")]
	private AstParserRuleReturnScope<object, IToken> booleanAndExpression()
	{
		EnterRule_booleanAndExpression();
		EnterRule("booleanAndExpression", 34);
		TraceIn("booleanAndExpression", 34);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OP_AND134 = default(IToken);
		AstParserRuleReturnScope<object, IToken> equalityExpression133 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> booleanAndExpression135 = default(AstParserRuleReturnScope<object, IToken>);

		object OP_AND134_tree = default(object);
		RewriteRuleITokenStream stream_OP_AND=new RewriteRuleITokenStream(adaptor,"token OP_AND");
		RewriteRuleSubtreeStream stream_equalityExpression=new RewriteRuleSubtreeStream(adaptor,"rule equalityExpression");
		RewriteRuleSubtreeStream stream_booleanAndExpression=new RewriteRuleSubtreeStream(adaptor,"rule booleanAndExpression");
		try { DebugEnterRule(GrammarFileName, "booleanAndExpression");
		DebugLocation(745, 4);
		try
		{
			// MapCSS.g:746:5: ( equalityExpression ( ( OP_AND )=> OP_AND booleanAndExpression -> ^( OP_AND equalityExpression booleanAndExpression ) | -> equalityExpression ) )
			DebugEnterAlt(1);
			// MapCSS.g:746:10: equalityExpression ( ( OP_AND )=> OP_AND booleanAndExpression -> ^( OP_AND equalityExpression booleanAndExpression ) | -> equalityExpression )
			{
			DebugLocation(746, 10);
			PushFollow(Follow._equalityExpression_in_booleanAndExpression4741);
			equalityExpression133=equalityExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_equalityExpression.Add(equalityExpression133.Tree);
			DebugLocation(746, 29);
			// MapCSS.g:746:29: ( ( OP_AND )=> OP_AND booleanAndExpression -> ^( OP_AND equalityExpression booleanAndExpression ) | -> equalityExpression )
			int alt33=2;
			try { DebugEnterSubRule(33);
			try { DebugEnterDecision(33, false);
			int LA33_1 = input.LA(1);

			if ((LA33_1==OP_AND) && (EvaluatePredicate(synpred2_MapCSS_fragment)))
			{
				alt33 = 1;
			}
			else if ((LA33_1==OP_OR||(LA33_1>=118 && LA33_1<=119)))
			{
				alt33 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 33, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:747:14: ( OP_AND )=> OP_AND booleanAndExpression
				{
				DebugLocation(747, 26);
				OP_AND134=(IToken)Match(input,OP_AND,Follow._OP_AND_in_booleanAndExpression4765); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_AND.Add(OP_AND134);

				DebugLocation(747, 33);
				PushFollow(Follow._booleanAndExpression_in_booleanAndExpression4767);
				booleanAndExpression135=booleanAndExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_booleanAndExpression.Add(booleanAndExpression135.Tree);


				{
				// AST REWRITE
				// elements: OP_AND, equalityExpression, booleanAndExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 747:54: -> ^( OP_AND equalityExpression booleanAndExpression )
				{
					DebugLocation(747, 57);
					// MapCSS.g:747:57: ^( OP_AND equalityExpression booleanAndExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(747, 59);
					root_1 = (object)adaptor.BecomeRoot(stream_OP_AND.NextNode(), root_1);

					DebugLocation(747, 66);
					adaptor.AddChild(root_1, stream_equalityExpression.NextTree());
					DebugLocation(747, 85);
					adaptor.AddChild(root_1, stream_booleanAndExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:748:50: 
				{

				{
				// AST REWRITE
				// elements: equalityExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 748:50: -> equalityExpression
				{
					DebugLocation(748, 53);
					adaptor.AddChild(root_0, stream_equalityExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(33); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("booleanAndExpression", 34);
			LeaveRule("booleanAndExpression", 34);
			LeaveRule_booleanAndExpression();
		}
		DebugLocation(750, 4);
		} finally { DebugExitRule(GrammarFileName, "booleanAndExpression"); }
		return retval;

	}
	// $ANTLR end "booleanAndExpression"

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();
	// $ANTLR start "equalityExpression"
	// MapCSS.g:752:1: equalityExpression : relationalExpression ( ( OP_EQ )=> OP_EQ relationalExpression -> ^( OP_EQ ( relationalExpression )+ ) | ( OP_NEQ )=> OP_NEQ relationalExpression -> ^( OP_NEQ ( relationalExpression )+ ) | -> relationalExpression ) ;
	[GrammarRule("equalityExpression")]
	private AstParserRuleReturnScope<object, IToken> equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 35);
		TraceIn("equalityExpression", 35);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OP_EQ137 = default(IToken);
		IToken OP_NEQ139 = default(IToken);
		AstParserRuleReturnScope<object, IToken> relationalExpression136 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> relationalExpression138 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> relationalExpression140 = default(AstParserRuleReturnScope<object, IToken>);

		object OP_EQ137_tree = default(object);
		object OP_NEQ139_tree = default(object);
		RewriteRuleITokenStream stream_OP_EQ=new RewriteRuleITokenStream(adaptor,"token OP_EQ");
		RewriteRuleITokenStream stream_OP_NEQ=new RewriteRuleITokenStream(adaptor,"token OP_NEQ");
		RewriteRuleSubtreeStream stream_relationalExpression=new RewriteRuleSubtreeStream(adaptor,"rule relationalExpression");
		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(752, 4);
		try
		{
			// MapCSS.g:753:5: ( relationalExpression ( ( OP_EQ )=> OP_EQ relationalExpression -> ^( OP_EQ ( relationalExpression )+ ) | ( OP_NEQ )=> OP_NEQ relationalExpression -> ^( OP_NEQ ( relationalExpression )+ ) | -> relationalExpression ) )
			DebugEnterAlt(1);
			// MapCSS.g:753:10: relationalExpression ( ( OP_EQ )=> OP_EQ relationalExpression -> ^( OP_EQ ( relationalExpression )+ ) | ( OP_NEQ )=> OP_NEQ relationalExpression -> ^( OP_NEQ ( relationalExpression )+ ) | -> relationalExpression )
			{
			DebugLocation(753, 10);
			PushFollow(Follow._relationalExpression_in_equalityExpression4871);
			relationalExpression136=relationalExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_relationalExpression.Add(relationalExpression136.Tree);
			DebugLocation(753, 31);
			// MapCSS.g:753:31: ( ( OP_EQ )=> OP_EQ relationalExpression -> ^( OP_EQ ( relationalExpression )+ ) | ( OP_NEQ )=> OP_NEQ relationalExpression -> ^( OP_NEQ ( relationalExpression )+ ) | -> relationalExpression )
			int alt34=3;
			try { DebugEnterSubRule(34);
			try { DebugEnterDecision(34, false);
			int LA34_1 = input.LA(1);

			if ((LA34_1==OP_EQ) && (EvaluatePredicate(synpred3_MapCSS_fragment)))
			{
				alt34 = 1;
			}
			else if ((LA34_1==OP_NEQ) && (EvaluatePredicate(synpred4_MapCSS_fragment)))
			{
				alt34 = 2;
			}
			else if ((LA34_1==OP_AND||LA34_1==OP_OR||(LA34_1>=118 && LA34_1<=119)))
			{
				alt34 = 3;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 34, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:754:14: ( OP_EQ )=> OP_EQ relationalExpression
				{
				DebugLocation(754, 26);
				OP_EQ137=(IToken)Match(input,OP_EQ,Follow._OP_EQ_in_equalityExpression4895); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_EQ.Add(OP_EQ137);

				DebugLocation(754, 33);
				PushFollow(Follow._relationalExpression_in_equalityExpression4898);
				relationalExpression138=relationalExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_relationalExpression.Add(relationalExpression138.Tree);


				{
				// AST REWRITE
				// elements: OP_EQ, relationalExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 754:54: -> ^( OP_EQ ( relationalExpression )+ )
				{
					DebugLocation(754, 57);
					// MapCSS.g:754:57: ^( OP_EQ ( relationalExpression )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(754, 59);
					root_1 = (object)adaptor.BecomeRoot(stream_OP_EQ.NextNode(), root_1);

					DebugLocation(754, 66);
					if (!(stream_relationalExpression.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_relationalExpression.HasNext )
					{
						DebugLocation(754, 66);
						adaptor.AddChild(root_1, stream_relationalExpression.NextTree());

					}
					stream_relationalExpression.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:755:14: ( OP_NEQ )=> OP_NEQ relationalExpression
				{
				DebugLocation(755, 26);
				OP_NEQ139=(IToken)Match(input,OP_NEQ,Follow._OP_NEQ_in_equalityExpression4929); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_NEQ.Add(OP_NEQ139);

				DebugLocation(755, 33);
				PushFollow(Follow._relationalExpression_in_equalityExpression4931);
				relationalExpression140=relationalExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_relationalExpression.Add(relationalExpression140.Tree);


				{
				// AST REWRITE
				// elements: OP_NEQ, relationalExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 755:54: -> ^( OP_NEQ ( relationalExpression )+ )
				{
					DebugLocation(755, 57);
					// MapCSS.g:755:57: ^( OP_NEQ ( relationalExpression )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(755, 59);
					root_1 = (object)adaptor.BecomeRoot(stream_OP_NEQ.NextNode(), root_1);

					DebugLocation(755, 66);
					if (!(stream_relationalExpression.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_relationalExpression.HasNext )
					{
						DebugLocation(755, 66);
						adaptor.AddChild(root_1, stream_relationalExpression.NextTree());

					}
					stream_relationalExpression.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:756:50: 
				{

				{
				// AST REWRITE
				// elements: relationalExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 756:50: -> relationalExpression
				{
					DebugLocation(756, 53);
					adaptor.AddChild(root_0, stream_relationalExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(34); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 35);
			LeaveRule("equalityExpression", 35);
			LeaveRule_equalityExpression();
		}
		DebugLocation(758, 4);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();
	// $ANTLR start "relationalExpression"
	// MapCSS.g:760:1: relationalExpression : additiveExpression ( ( OP_LT )=> OP_LT additiveExpression -> ^( OP_LT ( additiveExpression )+ ) | ( OP_LE )=> OP_LE additiveExpression -> ^( OP_LE ( additiveExpression )+ ) | ( OP_GT )=> OP_GT additiveExpression -> ^( OP_GT ( additiveExpression )+ ) | ( OP_GE )=> OP_GE additiveExpression -> ^( OP_GE ( additiveExpression )+ ) | -> additiveExpression ) ;
	[GrammarRule("relationalExpression")]
	private AstParserRuleReturnScope<object, IToken> relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 36);
		TraceIn("relationalExpression", 36);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OP_LT142 = default(IToken);
		IToken OP_LE144 = default(IToken);
		IToken OP_GT146 = default(IToken);
		IToken OP_GE148 = default(IToken);
		AstParserRuleReturnScope<object, IToken> additiveExpression141 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> additiveExpression143 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> additiveExpression145 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> additiveExpression147 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> additiveExpression149 = default(AstParserRuleReturnScope<object, IToken>);

		object OP_LT142_tree = default(object);
		object OP_LE144_tree = default(object);
		object OP_GT146_tree = default(object);
		object OP_GE148_tree = default(object);
		RewriteRuleITokenStream stream_OP_LT=new RewriteRuleITokenStream(adaptor,"token OP_LT");
		RewriteRuleITokenStream stream_OP_LE=new RewriteRuleITokenStream(adaptor,"token OP_LE");
		RewriteRuleITokenStream stream_OP_GT=new RewriteRuleITokenStream(adaptor,"token OP_GT");
		RewriteRuleITokenStream stream_OP_GE=new RewriteRuleITokenStream(adaptor,"token OP_GE");
		RewriteRuleSubtreeStream stream_additiveExpression=new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");
		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(760, 4);
		try
		{
			// MapCSS.g:761:5: ( additiveExpression ( ( OP_LT )=> OP_LT additiveExpression -> ^( OP_LT ( additiveExpression )+ ) | ( OP_LE )=> OP_LE additiveExpression -> ^( OP_LE ( additiveExpression )+ ) | ( OP_GT )=> OP_GT additiveExpression -> ^( OP_GT ( additiveExpression )+ ) | ( OP_GE )=> OP_GE additiveExpression -> ^( OP_GE ( additiveExpression )+ ) | -> additiveExpression ) )
			DebugEnterAlt(1);
			// MapCSS.g:761:9: additiveExpression ( ( OP_LT )=> OP_LT additiveExpression -> ^( OP_LT ( additiveExpression )+ ) | ( OP_LE )=> OP_LE additiveExpression -> ^( OP_LE ( additiveExpression )+ ) | ( OP_GT )=> OP_GT additiveExpression -> ^( OP_GT ( additiveExpression )+ ) | ( OP_GE )=> OP_GE additiveExpression -> ^( OP_GE ( additiveExpression )+ ) | -> additiveExpression )
			{
			DebugLocation(761, 9);
			PushFollow(Follow._additiveExpression_in_relationalExpression5037);
			additiveExpression141=additiveExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_additiveExpression.Add(additiveExpression141.Tree);
			DebugLocation(761, 28);
			// MapCSS.g:761:28: ( ( OP_LT )=> OP_LT additiveExpression -> ^( OP_LT ( additiveExpression )+ ) | ( OP_LE )=> OP_LE additiveExpression -> ^( OP_LE ( additiveExpression )+ ) | ( OP_GT )=> OP_GT additiveExpression -> ^( OP_GT ( additiveExpression )+ ) | ( OP_GE )=> OP_GE additiveExpression -> ^( OP_GE ( additiveExpression )+ ) | -> additiveExpression )
			int alt35=5;
			try { DebugEnterSubRule(35);
			try { DebugEnterDecision(35, false);
			int LA35_1 = input.LA(1);

			if ((LA35_1==OP_LT) && (EvaluatePredicate(synpred5_MapCSS_fragment)))
			{
				alt35 = 1;
			}
			else if ((LA35_1==OP_LE) && (EvaluatePredicate(synpred6_MapCSS_fragment)))
			{
				alt35 = 2;
			}
			else if ((LA35_1==OP_GT) && (EvaluatePredicate(synpred7_MapCSS_fragment)))
			{
				alt35 = 3;
			}
			else if ((LA35_1==OP_GE) && (EvaluatePredicate(synpred8_MapCSS_fragment)))
			{
				alt35 = 4;
			}
			else if ((LA35_1==OP_AND||LA35_1==OP_EQ||LA35_1==OP_NEQ||LA35_1==OP_OR||(LA35_1>=118 && LA35_1<=119)))
			{
				alt35 = 5;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 35, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:762:13: ( OP_LT )=> OP_LT additiveExpression
				{
				DebugLocation(762, 25);
				OP_LT142=(IToken)Match(input,OP_LT,Follow._OP_LT_in_relationalExpression5061); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_LT.Add(OP_LT142);

				DebugLocation(762, 31);
				PushFollow(Follow._additiveExpression_in_relationalExpression5063);
				additiveExpression143=additiveExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_additiveExpression.Add(additiveExpression143.Tree);


				{
				// AST REWRITE
				// elements: OP_LT, additiveExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 762:51: -> ^( OP_LT ( additiveExpression )+ )
				{
					DebugLocation(762, 54);
					// MapCSS.g:762:54: ^( OP_LT ( additiveExpression )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(762, 56);
					root_1 = (object)adaptor.BecomeRoot(stream_OP_LT.NextNode(), root_1);

					DebugLocation(762, 62);
					if (!(stream_additiveExpression.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_additiveExpression.HasNext )
					{
						DebugLocation(762, 62);
						adaptor.AddChild(root_1, stream_additiveExpression.NextTree());

					}
					stream_additiveExpression.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:763:13: ( OP_LE )=> OP_LE additiveExpression
				{
				DebugLocation(763, 25);
				OP_LE144=(IToken)Match(input,OP_LE,Follow._OP_LE_in_relationalExpression5094); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_LE.Add(OP_LE144);

				DebugLocation(763, 31);
				PushFollow(Follow._additiveExpression_in_relationalExpression5096);
				additiveExpression145=additiveExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_additiveExpression.Add(additiveExpression145.Tree);


				{
				// AST REWRITE
				// elements: OP_LE, additiveExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 763:51: -> ^( OP_LE ( additiveExpression )+ )
				{
					DebugLocation(763, 54);
					// MapCSS.g:763:54: ^( OP_LE ( additiveExpression )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(763, 56);
					root_1 = (object)adaptor.BecomeRoot(stream_OP_LE.NextNode(), root_1);

					DebugLocation(763, 62);
					if (!(stream_additiveExpression.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_additiveExpression.HasNext )
					{
						DebugLocation(763, 62);
						adaptor.AddChild(root_1, stream_additiveExpression.NextTree());

					}
					stream_additiveExpression.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:764:13: ( OP_GT )=> OP_GT additiveExpression
				{
				DebugLocation(764, 25);
				OP_GT146=(IToken)Match(input,OP_GT,Follow._OP_GT_in_relationalExpression5127); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_GT.Add(OP_GT146);

				DebugLocation(764, 31);
				PushFollow(Follow._additiveExpression_in_relationalExpression5129);
				additiveExpression147=additiveExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_additiveExpression.Add(additiveExpression147.Tree);


				{
				// AST REWRITE
				// elements: OP_GT, additiveExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 764:51: -> ^( OP_GT ( additiveExpression )+ )
				{
					DebugLocation(764, 54);
					// MapCSS.g:764:54: ^( OP_GT ( additiveExpression )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(764, 56);
					root_1 = (object)adaptor.BecomeRoot(stream_OP_GT.NextNode(), root_1);

					DebugLocation(764, 62);
					if (!(stream_additiveExpression.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_additiveExpression.HasNext )
					{
						DebugLocation(764, 62);
						adaptor.AddChild(root_1, stream_additiveExpression.NextTree());

					}
					stream_additiveExpression.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// MapCSS.g:765:13: ( OP_GE )=> OP_GE additiveExpression
				{
				DebugLocation(765, 25);
				OP_GE148=(IToken)Match(input,OP_GE,Follow._OP_GE_in_relationalExpression5160); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_GE.Add(OP_GE148);

				DebugLocation(765, 31);
				PushFollow(Follow._additiveExpression_in_relationalExpression5162);
				additiveExpression149=additiveExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_additiveExpression.Add(additiveExpression149.Tree);


				{
				// AST REWRITE
				// elements: OP_GE, additiveExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 765:51: -> ^( OP_GE ( additiveExpression )+ )
				{
					DebugLocation(765, 54);
					// MapCSS.g:765:54: ^( OP_GE ( additiveExpression )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(765, 56);
					root_1 = (object)adaptor.BecomeRoot(stream_OP_GE.NextNode(), root_1);

					DebugLocation(765, 62);
					if (!(stream_additiveExpression.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_additiveExpression.HasNext )
					{
						DebugLocation(765, 62);
						adaptor.AddChild(root_1, stream_additiveExpression.NextTree());

					}
					stream_additiveExpression.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// MapCSS.g:766:45: 
				{

				{
				// AST REWRITE
				// elements: additiveExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 766:45: -> additiveExpression
				{
					DebugLocation(766, 48);
					adaptor.AddChild(root_0, stream_additiveExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(35); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 36);
			LeaveRule("relationalExpression", 36);
			LeaveRule_relationalExpression();
		}
		DebugLocation(768, 4);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();
	// $ANTLR start "additiveExpression"
	// MapCSS.g:770:1: additiveExpression : multiplicativeExpression ( ( OP_PLUS )=> OP_PLUS additiveExpression -> ^( OP_PLUS multiplicativeExpression additiveExpression ) | ( '-' )=> '-' additiveExpression -> ^( OP_MINUS multiplicativeExpression additiveExpression ) | -> multiplicativeExpression ) ;
	[GrammarRule("additiveExpression")]
	private AstParserRuleReturnScope<object, IToken> additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 37);
		TraceIn("additiveExpression", 37);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OP_PLUS151 = default(IToken);
		IToken char_literal153 = default(IToken);
		AstParserRuleReturnScope<object, IToken> multiplicativeExpression150 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> additiveExpression152 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> additiveExpression154 = default(AstParserRuleReturnScope<object, IToken>);

		object OP_PLUS151_tree = default(object);
		object char_literal153_tree = default(object);
		RewriteRuleITokenStream stream_OP_PLUS=new RewriteRuleITokenStream(adaptor,"token OP_PLUS");
		RewriteRuleITokenStream stream_120=new RewriteRuleITokenStream(adaptor,"token 120");
		RewriteRuleSubtreeStream stream_multiplicativeExpression=new RewriteRuleSubtreeStream(adaptor,"rule multiplicativeExpression");
		RewriteRuleSubtreeStream stream_additiveExpression=new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(770, 4);
		try
		{
			// MapCSS.g:771:5: ( multiplicativeExpression ( ( OP_PLUS )=> OP_PLUS additiveExpression -> ^( OP_PLUS multiplicativeExpression additiveExpression ) | ( '-' )=> '-' additiveExpression -> ^( OP_MINUS multiplicativeExpression additiveExpression ) | -> multiplicativeExpression ) )
			DebugEnterAlt(1);
			// MapCSS.g:771:10: multiplicativeExpression ( ( OP_PLUS )=> OP_PLUS additiveExpression -> ^( OP_PLUS multiplicativeExpression additiveExpression ) | ( '-' )=> '-' additiveExpression -> ^( OP_MINUS multiplicativeExpression additiveExpression ) | -> multiplicativeExpression )
			{
			DebugLocation(771, 10);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression5250);
			multiplicativeExpression150=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_multiplicativeExpression.Add(multiplicativeExpression150.Tree);
			DebugLocation(771, 35);
			// MapCSS.g:771:35: ( ( OP_PLUS )=> OP_PLUS additiveExpression -> ^( OP_PLUS multiplicativeExpression additiveExpression ) | ( '-' )=> '-' additiveExpression -> ^( OP_MINUS multiplicativeExpression additiveExpression ) | -> multiplicativeExpression )
			int alt36=3;
			try { DebugEnterSubRule(36);
			try { DebugEnterDecision(36, false);
			int LA36_1 = input.LA(1);

			if ((LA36_1==OP_PLUS) && (EvaluatePredicate(synpred9_MapCSS_fragment)))
			{
				alt36 = 1;
			}
			else if ((LA36_1==120) && (EvaluatePredicate(synpred10_MapCSS_fragment)))
			{
				alt36 = 2;
			}
			else if ((LA36_1==OP_AND||LA36_1==OP_EQ||(LA36_1>=OP_GE && LA36_1<=OP_LT)||LA36_1==OP_NEQ||LA36_1==OP_OR||(LA36_1>=118 && LA36_1<=119)))
			{
				alt36 = 3;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 36, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:772:14: ( OP_PLUS )=> OP_PLUS additiveExpression
				{
				DebugLocation(772, 27);
				OP_PLUS151=(IToken)Match(input,OP_PLUS,Follow._OP_PLUS_in_additiveExpression5274); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_PLUS.Add(OP_PLUS151);

				DebugLocation(772, 36);
				PushFollow(Follow._additiveExpression_in_additiveExpression5277);
				additiveExpression152=additiveExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_additiveExpression.Add(additiveExpression152.Tree);


				{
				// AST REWRITE
				// elements: OP_PLUS, multiplicativeExpression, additiveExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 772:55: -> ^( OP_PLUS multiplicativeExpression additiveExpression )
				{
					DebugLocation(772, 58);
					// MapCSS.g:772:58: ^( OP_PLUS multiplicativeExpression additiveExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(772, 60);
					root_1 = (object)adaptor.BecomeRoot(stream_OP_PLUS.NextNode(), root_1);

					DebugLocation(772, 68);
					adaptor.AddChild(root_1, stream_multiplicativeExpression.NextTree());
					DebugLocation(772, 93);
					adaptor.AddChild(root_1, stream_additiveExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:773:14: ( '-' )=> '-' additiveExpression
				{
				DebugLocation(773, 23);
				char_literal153=(IToken)Match(input,120,Follow._120_in_additiveExpression5308); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_120.Add(char_literal153);

				DebugLocation(773, 28);
				PushFollow(Follow._additiveExpression_in_additiveExpression5311);
				additiveExpression154=additiveExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_additiveExpression.Add(additiveExpression154.Tree);


				{
				// AST REWRITE
				// elements: multiplicativeExpression, additiveExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 773:47: -> ^( OP_MINUS multiplicativeExpression additiveExpression )
				{
					DebugLocation(773, 50);
					// MapCSS.g:773:50: ^( OP_MINUS multiplicativeExpression additiveExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(773, 52);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(OP_MINUS, "OP_MINUS"), root_1);

					DebugLocation(773, 61);
					adaptor.AddChild(root_1, stream_multiplicativeExpression.NextTree());
					DebugLocation(773, 86);
					adaptor.AddChild(root_1, stream_additiveExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:774:47: 
				{

				{
				// AST REWRITE
				// elements: multiplicativeExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 774:47: -> multiplicativeExpression
				{
					DebugLocation(774, 50);
					adaptor.AddChild(root_0, stream_multiplicativeExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(36); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 37);
			LeaveRule("additiveExpression", 37);
			LeaveRule_additiveExpression();
		}
		DebugLocation(776, 4);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();
	// $ANTLR start "multiplicativeExpression"
	// MapCSS.g:778:1: multiplicativeExpression : unaryExpression ( ( OP_MUL )=> ( OP_MUL multiplicativeExpression ) -> ^( OP_MUL unaryExpression multiplicativeExpression ) | ( DIV )=> ( DIV multiplicativeExpression ) -> ^( OP_DIV unaryExpression multiplicativeExpression ) | ( OP_MOD )=> ( OP_MOD multiplicativeExpression ) -> ^( OP_MOD unaryExpression multiplicativeExpression ) | -> unaryExpression ) ;
	[GrammarRule("multiplicativeExpression")]
	private AstParserRuleReturnScope<object, IToken> multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 38);
		TraceIn("multiplicativeExpression", 38);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OP_MUL156 = default(IToken);
		IToken DIV158 = default(IToken);
		IToken OP_MOD160 = default(IToken);
		AstParserRuleReturnScope<object, IToken> unaryExpression155 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> multiplicativeExpression157 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> multiplicativeExpression159 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> multiplicativeExpression161 = default(AstParserRuleReturnScope<object, IToken>);

		object OP_MUL156_tree = default(object);
		object DIV158_tree = default(object);
		object OP_MOD160_tree = default(object);
		RewriteRuleITokenStream stream_OP_MUL=new RewriteRuleITokenStream(adaptor,"token OP_MUL");
		RewriteRuleITokenStream stream_DIV=new RewriteRuleITokenStream(adaptor,"token DIV");
		RewriteRuleITokenStream stream_OP_MOD=new RewriteRuleITokenStream(adaptor,"token OP_MOD");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		RewriteRuleSubtreeStream stream_multiplicativeExpression=new RewriteRuleSubtreeStream(adaptor,"rule multiplicativeExpression");
		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(778, 4);
		try
		{
			// MapCSS.g:779:5: ( unaryExpression ( ( OP_MUL )=> ( OP_MUL multiplicativeExpression ) -> ^( OP_MUL unaryExpression multiplicativeExpression ) | ( DIV )=> ( DIV multiplicativeExpression ) -> ^( OP_DIV unaryExpression multiplicativeExpression ) | ( OP_MOD )=> ( OP_MOD multiplicativeExpression ) -> ^( OP_MOD unaryExpression multiplicativeExpression ) | -> unaryExpression ) )
			DebugEnterAlt(1);
			// MapCSS.g:779:8: unaryExpression ( ( OP_MUL )=> ( OP_MUL multiplicativeExpression ) -> ^( OP_MUL unaryExpression multiplicativeExpression ) | ( DIV )=> ( DIV multiplicativeExpression ) -> ^( OP_DIV unaryExpression multiplicativeExpression ) | ( OP_MOD )=> ( OP_MOD multiplicativeExpression ) -> ^( OP_MOD unaryExpression multiplicativeExpression ) | -> unaryExpression )
			{
			DebugLocation(779, 8);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression5400);
			unaryExpression155=unaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression155.Tree);
			DebugLocation(779, 24);
			// MapCSS.g:779:24: ( ( OP_MUL )=> ( OP_MUL multiplicativeExpression ) -> ^( OP_MUL unaryExpression multiplicativeExpression ) | ( DIV )=> ( DIV multiplicativeExpression ) -> ^( OP_DIV unaryExpression multiplicativeExpression ) | ( OP_MOD )=> ( OP_MOD multiplicativeExpression ) -> ^( OP_MOD unaryExpression multiplicativeExpression ) | -> unaryExpression )
			int alt37=4;
			try { DebugEnterSubRule(37);
			try { DebugEnterDecision(37, false);
			int LA37_1 = input.LA(1);

			if ((LA37_1==OP_MUL) && (EvaluatePredicate(synpred11_MapCSS_fragment)))
			{
				alt37 = 1;
			}
			else if ((LA37_1==DIV) && (EvaluatePredicate(synpred12_MapCSS_fragment)))
			{
				alt37 = 2;
			}
			else if ((LA37_1==OP_MOD) && (EvaluatePredicate(synpred13_MapCSS_fragment)))
			{
				alt37 = 3;
			}
			else if ((LA37_1==OP_AND||LA37_1==OP_EQ||(LA37_1>=OP_GE && LA37_1<=OP_LT)||LA37_1==OP_NEQ||(LA37_1>=OP_OR && LA37_1<=OP_PLUS)||(LA37_1>=118 && LA37_1<=120)))
			{
				alt37 = 4;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 37, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:780:10: ( OP_MUL )=> ( OP_MUL multiplicativeExpression )
				{
				DebugLocation(780, 22);
				// MapCSS.g:780:22: ( OP_MUL multiplicativeExpression )
				DebugEnterAlt(1);
				// MapCSS.g:780:23: OP_MUL multiplicativeExpression
				{
				DebugLocation(780, 23);
				OP_MUL156=(IToken)Match(input,OP_MUL,Follow._OP_MUL_in_multiplicativeExpression5420); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_MUL.Add(OP_MUL156);

				DebugLocation(780, 30);
				PushFollow(Follow._multiplicativeExpression_in_multiplicativeExpression5422);
				multiplicativeExpression157=multiplicativeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_multiplicativeExpression.Add(multiplicativeExpression157.Tree);

				}



				{
				// AST REWRITE
				// elements: OP_MUL, unaryExpression, multiplicativeExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 780:56: -> ^( OP_MUL unaryExpression multiplicativeExpression )
				{
					DebugLocation(780, 59);
					// MapCSS.g:780:59: ^( OP_MUL unaryExpression multiplicativeExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(780, 61);
					root_1 = (object)adaptor.BecomeRoot(stream_OP_MUL.NextNode(), root_1);

					DebugLocation(780, 68);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());
					DebugLocation(780, 84);
					adaptor.AddChild(root_1, stream_multiplicativeExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:781:10: ( DIV )=> ( DIV multiplicativeExpression )
				{
				DebugLocation(781, 19);
				// MapCSS.g:781:19: ( DIV multiplicativeExpression )
				DebugEnterAlt(1);
				// MapCSS.g:781:20: DIV multiplicativeExpression
				{
				DebugLocation(781, 20);
				DIV158=(IToken)Match(input,DIV,Follow._DIV_in_multiplicativeExpression5451); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DIV.Add(DIV158);

				DebugLocation(781, 24);
				PushFollow(Follow._multiplicativeExpression_in_multiplicativeExpression5453);
				multiplicativeExpression159=multiplicativeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_multiplicativeExpression.Add(multiplicativeExpression159.Tree);

				}



				{
				// AST REWRITE
				// elements: unaryExpression, multiplicativeExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 781:50: -> ^( OP_DIV unaryExpression multiplicativeExpression )
				{
					DebugLocation(781, 53);
					// MapCSS.g:781:53: ^( OP_DIV unaryExpression multiplicativeExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(781, 55);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(OP_DIV, "OP_DIV"), root_1);

					DebugLocation(781, 62);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());
					DebugLocation(781, 78);
					adaptor.AddChild(root_1, stream_multiplicativeExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:782:10: ( OP_MOD )=> ( OP_MOD multiplicativeExpression )
				{
				DebugLocation(782, 22);
				// MapCSS.g:782:22: ( OP_MOD multiplicativeExpression )
				DebugEnterAlt(1);
				// MapCSS.g:782:23: OP_MOD multiplicativeExpression
				{
				DebugLocation(782, 23);
				OP_MOD160=(IToken)Match(input,OP_MOD,Follow._OP_MOD_in_multiplicativeExpression5482); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OP_MOD.Add(OP_MOD160);

				DebugLocation(782, 30);
				PushFollow(Follow._multiplicativeExpression_in_multiplicativeExpression5484);
				multiplicativeExpression161=multiplicativeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_multiplicativeExpression.Add(multiplicativeExpression161.Tree);

				}



				{
				// AST REWRITE
				// elements: OP_MOD, unaryExpression, multiplicativeExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 782:56: -> ^( OP_MOD unaryExpression multiplicativeExpression )
				{
					DebugLocation(782, 59);
					// MapCSS.g:782:59: ^( OP_MOD unaryExpression multiplicativeExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(782, 61);
					root_1 = (object)adaptor.BecomeRoot(stream_OP_MOD.NextNode(), root_1);

					DebugLocation(782, 68);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());
					DebugLocation(782, 84);
					adaptor.AddChild(root_1, stream_multiplicativeExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// MapCSS.g:783:50: 
				{

				{
				// AST REWRITE
				// elements: unaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 783:50: -> unaryExpression
				{
					DebugLocation(783, 53);
					adaptor.AddChild(root_0, stream_unaryExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(37); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 38);
			LeaveRule("multiplicativeExpression", 38);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(785, 4);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// MapCSS.g:787:1: unaryExpression : ( ( '!' )=> '!' primaryExpression -> ^( OP_NOT primaryExpression ) | primaryExpression -> primaryExpression );
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<object, IToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 39);
		TraceIn("unaryExpression", 39);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal162 = default(IToken);
		AstParserRuleReturnScope<object, IToken> primaryExpression163 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primaryExpression164 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal162_tree = default(object);
		RewriteRuleITokenStream stream_114=new RewriteRuleITokenStream(adaptor,"token 114");
		RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(787, 4);
		try
		{
			// MapCSS.g:788:5: ( ( '!' )=> '!' primaryExpression -> ^( OP_NOT primaryExpression ) | primaryExpression -> primaryExpression )
			int alt38=2;
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==114) && (EvaluatePredicate(synpred14_MapCSS_fragment)))
			{
				alt38 = 1;
			}
			else if ((LA38_1==CSS_IDENT||LA38_1==DQUOTED_STRING||(LA38_1>=NEGATIVE_FLOAT && LA38_1<=NEGATIVE_INT)||LA38_1==OSM_TAG||(LA38_1>=POSITIVE_FLOAT && LA38_1<=POSITIVE_INT)||LA38_1==SQUOTED_STRING||LA38_1==117))
			{
				alt38 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 38, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:788:13: ( '!' )=> '!' primaryExpression
				{
				DebugLocation(788, 22);
				char_literal162=(IToken)Match(input,114,Follow._114_in_unaryExpression5603); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_114.Add(char_literal162);

				DebugLocation(788, 26);
				PushFollow(Follow._primaryExpression_in_unaryExpression5605);
				primaryExpression163=primaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_primaryExpression.Add(primaryExpression163.Tree);


				{
				// AST REWRITE
				// elements: primaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 788:45: -> ^( OP_NOT primaryExpression )
				{
					DebugLocation(788, 48);
					// MapCSS.g:788:48: ^( OP_NOT primaryExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(788, 50);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(OP_NOT, "OP_NOT"), root_1);

					DebugLocation(788, 57);
					adaptor.AddChild(root_1, stream_primaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:789:13: primaryExpression
				{
				DebugLocation(789, 13);
				PushFollow(Follow._primaryExpression_in_unaryExpression5628);
				primaryExpression164=primaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_primaryExpression.Add(primaryExpression164.Tree);


				{
				// AST REWRITE
				// elements: primaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 789:45: -> primaryExpression
				{
					DebugLocation(789, 48);
					adaptor.AddChild(root_0, stream_primaryExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 39);
			LeaveRule("unaryExpression", 39);
			LeaveRule_unaryExpression();
		}
		DebugLocation(790, 4);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();
	// $ANTLR start "primaryExpression"
	// MapCSS.g:792:1: primaryExpression : ( '(' expr ')' -> expr |f= CSS_IDENT '(' ( args )? ')' -> ^( FUNCTION_CALL[$f] ( args )? ) |v= POSITIVE_FLOAT -> VALUE_FLOAT[$v] |v= POSITIVE_INT -> VALUE_INT[$v] |v= NEGATIVE_FLOAT -> VALUE_FLOAT[$v] |v= NEGATIVE_INT -> VALUE_INT[$v] | quoted | cssident |v= OSM_TAG -> VALUE_KEYWORD[$v] );
	[GrammarRule("primaryExpression")]
	private AstParserRuleReturnScope<object, IToken> primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 40);
		TraceIn("primaryExpression", 40);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken f = default(IToken);
		IToken v = default(IToken);
		IToken char_literal165 = default(IToken);
		IToken char_literal167 = default(IToken);
		IToken char_literal168 = default(IToken);
		IToken char_literal170 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr166 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> args169 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> quoted171 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> cssident172 = default(AstParserRuleReturnScope<object, IToken>);

		object f_tree = default(object);
		object v_tree = default(object);
		object char_literal165_tree = default(object);
		object char_literal167_tree = default(object);
		object char_literal168_tree = default(object);
		object char_literal170_tree = default(object);
		RewriteRuleITokenStream stream_117=new RewriteRuleITokenStream(adaptor,"token 117");
		RewriteRuleITokenStream stream_118=new RewriteRuleITokenStream(adaptor,"token 118");
		RewriteRuleITokenStream stream_CSS_IDENT=new RewriteRuleITokenStream(adaptor,"token CSS_IDENT");
		RewriteRuleITokenStream stream_POSITIVE_FLOAT=new RewriteRuleITokenStream(adaptor,"token POSITIVE_FLOAT");
		RewriteRuleITokenStream stream_POSITIVE_INT=new RewriteRuleITokenStream(adaptor,"token POSITIVE_INT");
		RewriteRuleITokenStream stream_NEGATIVE_FLOAT=new RewriteRuleITokenStream(adaptor,"token NEGATIVE_FLOAT");
		RewriteRuleITokenStream stream_NEGATIVE_INT=new RewriteRuleITokenStream(adaptor,"token NEGATIVE_INT");
		RewriteRuleITokenStream stream_OSM_TAG=new RewriteRuleITokenStream(adaptor,"token OSM_TAG");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_args=new RewriteRuleSubtreeStream(adaptor,"rule args");
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(792, 4);
		try
		{
			// MapCSS.g:793:5: ( '(' expr ')' -> expr |f= CSS_IDENT '(' ( args )? ')' -> ^( FUNCTION_CALL[$f] ( args )? ) |v= POSITIVE_FLOAT -> VALUE_FLOAT[$v] |v= POSITIVE_INT -> VALUE_INT[$v] |v= NEGATIVE_FLOAT -> VALUE_FLOAT[$v] |v= NEGATIVE_INT -> VALUE_INT[$v] | quoted | cssident |v= OSM_TAG -> VALUE_KEYWORD[$v] )
			int alt40=9;
			try { DebugEnterDecision(40, false);
			switch (input.LA(1))
			{
			case 117:
				{
				alt40 = 1;
				}
				break;
			case CSS_IDENT:
				{
				int LA40_2 = input.LA(2);

				if ((LA40_2==117))
				{
					alt40 = 2;
				}
				else if ((LA40_2==DIV||LA40_2==OP_AND||LA40_2==OP_EQ||(LA40_2>=OP_GE && LA40_2<=OP_LT)||(LA40_2>=OP_MOD && LA40_2<=OP_MUL)||LA40_2==OP_NEQ||(LA40_2>=OP_OR && LA40_2<=OP_PLUS)||(LA40_2>=118 && LA40_2<=120)))
				{
					alt40 = 8;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 40, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case POSITIVE_FLOAT:
				{
				alt40 = 3;
				}
				break;
			case POSITIVE_INT:
				{
				alt40 = 4;
				}
				break;
			case NEGATIVE_FLOAT:
				{
				alt40 = 5;
				}
				break;
			case NEGATIVE_INT:
				{
				alt40 = 6;
				}
				break;
			case DQUOTED_STRING:
			case SQUOTED_STRING:
				{
				alt40 = 7;
				}
				break;
			case OSM_TAG:
				{
				alt40 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 40, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(40); }
			switch (alt40)
			{
			case 1:
				DebugEnterAlt(1);
				// MapCSS.g:793:10: '(' expr ')'
				{
				DebugLocation(793, 10);
				char_literal165=(IToken)Match(input,117,Follow._117_in_primaryExpression5666); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_117.Add(char_literal165);

				DebugLocation(793, 14);
				PushFollow(Follow._expr_in_primaryExpression5668);
				expr166=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr166.Tree);
				DebugLocation(793, 19);
				char_literal167=(IToken)Match(input,118,Follow._118_in_primaryExpression5670); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_118.Add(char_literal167);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 793:28: -> expr
				{
					DebugLocation(793, 31);
					adaptor.AddChild(root_0, stream_expr.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// MapCSS.g:794:10: f= CSS_IDENT '(' ( args )? ')'
				{
				DebugLocation(794, 11);
				f=(IToken)Match(input,CSS_IDENT,Follow._CSS_IDENT_in_primaryExpression5692); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CSS_IDENT.Add(f);

				DebugLocation(794, 22);
				char_literal168=(IToken)Match(input,117,Follow._117_in_primaryExpression5694); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_117.Add(char_literal168);

				DebugLocation(794, 26);
				// MapCSS.g:794:26: ( args )?
				int alt39=2;
				try { DebugEnterSubRule(39);
				try { DebugEnterDecision(39, false);
				int LA39_1 = input.LA(1);

				if ((LA39_1==CSS_IDENT||LA39_1==DQUOTED_STRING||(LA39_1>=NEGATIVE_FLOAT && LA39_1<=NEGATIVE_INT)||LA39_1==OSM_TAG||(LA39_1>=POSITIVE_FLOAT && LA39_1<=POSITIVE_INT)||LA39_1==SQUOTED_STRING||LA39_1==114||LA39_1==117))
				{
					alt39 = 1;
				}
				} finally { DebugExitDecision(39); }
				switch (alt39)
				{
				case 1:
					DebugEnterAlt(1);
					// MapCSS.g:794:26: args
					{
					DebugLocation(794, 26);
					PushFollow(Follow._args_in_primaryExpression5696);
					args169=args();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_args.Add(args169.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(39); }

				DebugLocation(794, 32);
				char_literal170=(IToken)Match(input,118,Follow._118_in_primaryExpression5699); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_118.Add(char_literal170);



				{
				// AST REWRITE
				// elements: args
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 794:36: -> ^( FUNCTION_CALL[$f] ( args )? )
				{
					DebugLocation(794, 39);
					// MapCSS.g:794:39: ^( FUNCTION_CALL[$f] ( args )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(794, 41);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTION_CALL, f), root_1);

					DebugLocation(794, 59);
					// MapCSS.g:794:59: ( args )?
					if (stream_args.HasNext)
					{
						DebugLocation(794, 59);
						adaptor.AddChild(root_1, stream_args.NextTree());

					}
					stream_args.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// MapCSS.g:795:10: v= POSITIVE_FLOAT
				{
				DebugLocation(795, 11);
				v=(IToken)Match(input,POSITIVE_FLOAT,Follow._POSITIVE_FLOAT_in_primaryExpression5722); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_FLOAT.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 795:28: -> VALUE_FLOAT[$v]
				{
					DebugLocation(795, 32);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_FLOAT, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// MapCSS.g:796:10: v= POSITIVE_INT
				{
				DebugLocation(796, 11);
				v=(IToken)Match(input,POSITIVE_INT,Follow._POSITIVE_INT_in_primaryExpression5742); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSITIVE_INT.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 796:28: -> VALUE_INT[$v]
				{
					DebugLocation(796, 32);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_INT, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// MapCSS.g:797:10: v= NEGATIVE_FLOAT
				{
				DebugLocation(797, 11);
				v=(IToken)Match(input,NEGATIVE_FLOAT,Follow._NEGATIVE_FLOAT_in_primaryExpression5764); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NEGATIVE_FLOAT.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 797:28: -> VALUE_FLOAT[$v]
				{
					DebugLocation(797, 32);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_FLOAT, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// MapCSS.g:798:10: v= NEGATIVE_INT
				{
				DebugLocation(798, 11);
				v=(IToken)Match(input,NEGATIVE_INT,Follow._NEGATIVE_INT_in_primaryExpression5784); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NEGATIVE_INT.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 798:28: -> VALUE_INT[$v]
				{
					DebugLocation(798, 32);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_INT, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// MapCSS.g:799:10: quoted
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(799, 10);
				PushFollow(Follow._quoted_in_primaryExpression5804);
				quoted171=quoted();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, quoted171.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// MapCSS.g:800:10: cssident
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(800, 10);
				PushFollow(Follow._cssident_in_primaryExpression5815);
				cssident172=cssident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, cssident172.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// MapCSS.g:801:10: v= OSM_TAG
				{
				DebugLocation(801, 11);
				v=(IToken)Match(input,OSM_TAG,Follow._OSM_TAG_in_primaryExpression5828); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OSM_TAG.Add(v);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 801:22: -> VALUE_KEYWORD[$v]
				{
					DebugLocation(801, 25);
					adaptor.AddChild(root_0, (object)adaptor.Create(VALUE_KEYWORD, v));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 40);
			LeaveRule("primaryExpression", 40);
			LeaveRule_primaryExpression();
		}
		DebugLocation(802, 4);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"

	partial void EnterRule_synpred1_MapCSS_fragment();
	partial void LeaveRule_synpred1_MapCSS_fragment();

	// $ANTLR start synpred1_MapCSS
	private void synpred1_MapCSS_fragment()
	{
		EnterRule_synpred1_MapCSS_fragment();
		EnterRule("synpred1_MapCSS_fragment", 41);
		TraceIn("synpred1_MapCSS_fragment", 41);
		try
		{
			// MapCSS.g:740:14: ( OP_OR )
			DebugEnterAlt(1);
			// MapCSS.g:740:15: OP_OR
			{
			DebugLocation(740, 15);
			Match(input,OP_OR,Follow._OP_OR_in_synpred1_MapCSS4641); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_MapCSS_fragment", 41);
			LeaveRule("synpred1_MapCSS_fragment", 41);
			LeaveRule_synpred1_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred1_MapCSS

	partial void EnterRule_synpred2_MapCSS_fragment();
	partial void LeaveRule_synpred2_MapCSS_fragment();

	// $ANTLR start synpred2_MapCSS
	private void synpred2_MapCSS_fragment()
	{
		EnterRule_synpred2_MapCSS_fragment();
		EnterRule("synpred2_MapCSS_fragment", 42);
		TraceIn("synpred2_MapCSS_fragment", 42);
		try
		{
			// MapCSS.g:747:14: ( OP_AND )
			DebugEnterAlt(1);
			// MapCSS.g:747:15: OP_AND
			{
			DebugLocation(747, 15);
			Match(input,OP_AND,Follow._OP_AND_in_synpred2_MapCSS4760); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_MapCSS_fragment", 42);
			LeaveRule("synpred2_MapCSS_fragment", 42);
			LeaveRule_synpred2_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred2_MapCSS

	partial void EnterRule_synpred3_MapCSS_fragment();
	partial void LeaveRule_synpred3_MapCSS_fragment();

	// $ANTLR start synpred3_MapCSS
	private void synpred3_MapCSS_fragment()
	{
		EnterRule_synpred3_MapCSS_fragment();
		EnterRule("synpred3_MapCSS_fragment", 43);
		TraceIn("synpred3_MapCSS_fragment", 43);
		try
		{
			// MapCSS.g:754:14: ( OP_EQ )
			DebugEnterAlt(1);
			// MapCSS.g:754:15: OP_EQ
			{
			DebugLocation(754, 15);
			Match(input,OP_EQ,Follow._OP_EQ_in_synpred3_MapCSS4889); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_MapCSS_fragment", 43);
			LeaveRule("synpred3_MapCSS_fragment", 43);
			LeaveRule_synpred3_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred3_MapCSS

	partial void EnterRule_synpred4_MapCSS_fragment();
	partial void LeaveRule_synpred4_MapCSS_fragment();

	// $ANTLR start synpred4_MapCSS
	private void synpred4_MapCSS_fragment()
	{
		EnterRule_synpred4_MapCSS_fragment();
		EnterRule("synpred4_MapCSS_fragment", 44);
		TraceIn("synpred4_MapCSS_fragment", 44);
		try
		{
			// MapCSS.g:755:14: ( OP_NEQ )
			DebugEnterAlt(1);
			// MapCSS.g:755:15: OP_NEQ
			{
			DebugLocation(755, 15);
			Match(input,OP_NEQ,Follow._OP_NEQ_in_synpred4_MapCSS4924); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_MapCSS_fragment", 44);
			LeaveRule("synpred4_MapCSS_fragment", 44);
			LeaveRule_synpred4_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred4_MapCSS

	partial void EnterRule_synpred5_MapCSS_fragment();
	partial void LeaveRule_synpred5_MapCSS_fragment();

	// $ANTLR start synpred5_MapCSS
	private void synpred5_MapCSS_fragment()
	{
		EnterRule_synpred5_MapCSS_fragment();
		EnterRule("synpred5_MapCSS_fragment", 45);
		TraceIn("synpred5_MapCSS_fragment", 45);
		try
		{
			// MapCSS.g:762:13: ( OP_LT )
			DebugEnterAlt(1);
			// MapCSS.g:762:14: OP_LT
			{
			DebugLocation(762, 14);
			Match(input,OP_LT,Follow._OP_LT_in_synpred5_MapCSS5055); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_MapCSS_fragment", 45);
			LeaveRule("synpred5_MapCSS_fragment", 45);
			LeaveRule_synpred5_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred5_MapCSS

	partial void EnterRule_synpred6_MapCSS_fragment();
	partial void LeaveRule_synpred6_MapCSS_fragment();

	// $ANTLR start synpred6_MapCSS
	private void synpred6_MapCSS_fragment()
	{
		EnterRule_synpred6_MapCSS_fragment();
		EnterRule("synpred6_MapCSS_fragment", 46);
		TraceIn("synpred6_MapCSS_fragment", 46);
		try
		{
			// MapCSS.g:763:13: ( OP_LE )
			DebugEnterAlt(1);
			// MapCSS.g:763:14: OP_LE
			{
			DebugLocation(763, 14);
			Match(input,OP_LE,Follow._OP_LE_in_synpred6_MapCSS5088); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred6_MapCSS_fragment", 46);
			LeaveRule("synpred6_MapCSS_fragment", 46);
			LeaveRule_synpred6_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred6_MapCSS

	partial void EnterRule_synpred7_MapCSS_fragment();
	partial void LeaveRule_synpred7_MapCSS_fragment();

	// $ANTLR start synpred7_MapCSS
	private void synpred7_MapCSS_fragment()
	{
		EnterRule_synpred7_MapCSS_fragment();
		EnterRule("synpred7_MapCSS_fragment", 47);
		TraceIn("synpred7_MapCSS_fragment", 47);
		try
		{
			// MapCSS.g:764:13: ( OP_GT )
			DebugEnterAlt(1);
			// MapCSS.g:764:14: OP_GT
			{
			DebugLocation(764, 14);
			Match(input,OP_GT,Follow._OP_GT_in_synpred7_MapCSS5121); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred7_MapCSS_fragment", 47);
			LeaveRule("synpred7_MapCSS_fragment", 47);
			LeaveRule_synpred7_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred7_MapCSS

	partial void EnterRule_synpred8_MapCSS_fragment();
	partial void LeaveRule_synpred8_MapCSS_fragment();

	// $ANTLR start synpred8_MapCSS
	private void synpred8_MapCSS_fragment()
	{
		EnterRule_synpred8_MapCSS_fragment();
		EnterRule("synpred8_MapCSS_fragment", 48);
		TraceIn("synpred8_MapCSS_fragment", 48);
		try
		{
			// MapCSS.g:765:13: ( OP_GE )
			DebugEnterAlt(1);
			// MapCSS.g:765:14: OP_GE
			{
			DebugLocation(765, 14);
			Match(input,OP_GE,Follow._OP_GE_in_synpred8_MapCSS5154); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred8_MapCSS_fragment", 48);
			LeaveRule("synpred8_MapCSS_fragment", 48);
			LeaveRule_synpred8_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred8_MapCSS

	partial void EnterRule_synpred9_MapCSS_fragment();
	partial void LeaveRule_synpred9_MapCSS_fragment();

	// $ANTLR start synpred9_MapCSS
	private void synpred9_MapCSS_fragment()
	{
		EnterRule_synpred9_MapCSS_fragment();
		EnterRule("synpred9_MapCSS_fragment", 49);
		TraceIn("synpred9_MapCSS_fragment", 49);
		try
		{
			// MapCSS.g:772:14: ( OP_PLUS )
			DebugEnterAlt(1);
			// MapCSS.g:772:15: OP_PLUS
			{
			DebugLocation(772, 15);
			Match(input,OP_PLUS,Follow._OP_PLUS_in_synpred9_MapCSS5269); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred9_MapCSS_fragment", 49);
			LeaveRule("synpred9_MapCSS_fragment", 49);
			LeaveRule_synpred9_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred9_MapCSS

	partial void EnterRule_synpred10_MapCSS_fragment();
	partial void LeaveRule_synpred10_MapCSS_fragment();

	// $ANTLR start synpred10_MapCSS
	private void synpred10_MapCSS_fragment()
	{
		EnterRule_synpred10_MapCSS_fragment();
		EnterRule("synpred10_MapCSS_fragment", 50);
		TraceIn("synpred10_MapCSS_fragment", 50);
		try
		{
			// MapCSS.g:773:14: ( '-' )
			DebugEnterAlt(1);
			// MapCSS.g:773:15: '-'
			{
			DebugLocation(773, 15);
			Match(input,120,Follow._120_in_synpred10_MapCSS5303); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred10_MapCSS_fragment", 50);
			LeaveRule("synpred10_MapCSS_fragment", 50);
			LeaveRule_synpred10_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred10_MapCSS

	partial void EnterRule_synpred11_MapCSS_fragment();
	partial void LeaveRule_synpred11_MapCSS_fragment();

	// $ANTLR start synpred11_MapCSS
	private void synpred11_MapCSS_fragment()
	{
		EnterRule_synpred11_MapCSS_fragment();
		EnterRule("synpred11_MapCSS_fragment", 51);
		TraceIn("synpred11_MapCSS_fragment", 51);
		try
		{
			// MapCSS.g:780:10: ( OP_MUL )
			DebugEnterAlt(1);
			// MapCSS.g:780:11: OP_MUL
			{
			DebugLocation(780, 11);
			Match(input,OP_MUL,Follow._OP_MUL_in_synpred11_MapCSS5414); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred11_MapCSS_fragment", 51);
			LeaveRule("synpred11_MapCSS_fragment", 51);
			LeaveRule_synpred11_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred11_MapCSS

	partial void EnterRule_synpred12_MapCSS_fragment();
	partial void LeaveRule_synpred12_MapCSS_fragment();

	// $ANTLR start synpred12_MapCSS
	private void synpred12_MapCSS_fragment()
	{
		EnterRule_synpred12_MapCSS_fragment();
		EnterRule("synpred12_MapCSS_fragment", 52);
		TraceIn("synpred12_MapCSS_fragment", 52);
		try
		{
			// MapCSS.g:781:10: ( DIV )
			DebugEnterAlt(1);
			// MapCSS.g:781:11: DIV
			{
			DebugLocation(781, 11);
			Match(input,DIV,Follow._DIV_in_synpred12_MapCSS5445); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred12_MapCSS_fragment", 52);
			LeaveRule("synpred12_MapCSS_fragment", 52);
			LeaveRule_synpred12_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred12_MapCSS

	partial void EnterRule_synpred13_MapCSS_fragment();
	partial void LeaveRule_synpred13_MapCSS_fragment();

	// $ANTLR start synpred13_MapCSS
	private void synpred13_MapCSS_fragment()
	{
		EnterRule_synpred13_MapCSS_fragment();
		EnterRule("synpred13_MapCSS_fragment", 53);
		TraceIn("synpred13_MapCSS_fragment", 53);
		try
		{
			// MapCSS.g:782:10: ( OP_MOD )
			DebugEnterAlt(1);
			// MapCSS.g:782:11: OP_MOD
			{
			DebugLocation(782, 11);
			Match(input,OP_MOD,Follow._OP_MOD_in_synpred13_MapCSS5476); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred13_MapCSS_fragment", 53);
			LeaveRule("synpred13_MapCSS_fragment", 53);
			LeaveRule_synpred13_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred13_MapCSS

	partial void EnterRule_synpred14_MapCSS_fragment();
	partial void LeaveRule_synpred14_MapCSS_fragment();

	// $ANTLR start synpred14_MapCSS
	private void synpred14_MapCSS_fragment()
	{
		EnterRule_synpred14_MapCSS_fragment();
		EnterRule("synpred14_MapCSS_fragment", 54);
		TraceIn("synpred14_MapCSS_fragment", 54);
		try
		{
			// MapCSS.g:788:13: ( '!' )
			DebugEnterAlt(1);
			// MapCSS.g:788:14: '!'
			{
			DebugLocation(788, 14);
			Match(input,114,Follow._114_in_synpred14_MapCSS5598); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred14_MapCSS_fragment", 54);
			LeaveRule("synpred14_MapCSS_fragment", 54);
			LeaveRule_synpred14_MapCSS_fragment();
		}
	}
	// $ANTLR end synpred14_MapCSS
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
            OsmSharp.Logging.Log.TraceEvent("MapCSSParser", OsmSharp.Logging.TraceEventType.Error,
                "impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA6 dfa6;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa6 = new DFA6( this );
	}

	private class DFA6 : DFA
	{
		private const string DFA6_eotS =
			"\x36\xFFFF";
		private const string DFA6_eofS =
			"\x36\xFFFF";
		private const string DFA6_minS =
			"\x1\x9\x2\x8\x2\x9\x1\x8\x5\x9\x4\xFFFF\x2\x8\x8\x2B\x1\x9\x3\x8\x1\x9"+
			"\x1\xF\x1\x8\x1\x9\x1\xF\x6\x4D\x2\x76\xC\x4D";
		private const string DFA6_maxS =
			"\x1\x37\x2\x7B\x2\x9\x1\x7B\x1\x72\x4\x9\x4\xFFFF\x2\x7B\x4\x7C\x4\x3F"+
			"\x1\x5A\x3\x7B\x1\x77\x1\x5A\x1\x7B\x2\x5A\x6\x4D\x2\x76\xC\x4D";
		private const string DFA6_acceptS =
			"\xB\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x27\xFFFF";
		private const string DFA6_specialS =
			"\x36\xFFFF}>";
		private static readonly string[] DFA6_transitionS =
			{
				"\x1\x1\x2D\xFFFF\x1\x2",
				"\x1\x9\x1\xC\x15\xFFFF\x1\xB\x1\x6\x10\xFFFF\x1\xD\x1\xFFFF\x1\xE\x3"+
				"\xFFFF\x1\xC\x13\xFFFF\x1\x5\x27\xFFFF\x1\x3\x1\x8\x2\xFFFF\x1\xB\x1"+
				"\xFFFF\x1\x4\x1\x7\x1\xA",
				"\x1\x9\x1\xC\x15\xFFFF\x1\xB\x1\x6\x10\xFFFF\x1\xD\x1\xFFFF\x1\xE\x3"+
				"\xFFFF\x1\xC\x13\xFFFF\x1\x5\x27\xFFFF\x1\x3\x1\x8\x2\xFFFF\x1\xB\x1"+
				"\xFFFF\x1\x4\x1\x7\x1\xA",
				"\x1\xF",
				"\x1\x10",
				"\x1\x9\x1\xC\x15\xFFFF\x1\xB\x1\x6\x10\xFFFF\x1\xD\x1\xFFFF\x1\xE\x3"+
				"\xFFFF\x1\xC\x3C\xFFFF\x1\x8\x2\xFFFF\x1\xB\x2\xFFFF\x1\x7\x1\xA",
				"\x1\x11\x5\xFFFF\x1\x13\x14\xFFFF\x1\x18\x1\x16\x1B\xFFFF\x1\x12\x5"+
				"\xFFFF\x1\x17\x1\x15\x11\xFFFF\x1\x14\x17\xFFFF\x1\x19",
				"\x1\x1A",
				"\x1\x1B",
				"\x1\x1C",
				"\x1\x1D",
				"",
				"",
				"",
				"",
				"\x1\x9\x1\xC\x15\xFFFF\x1\xB\x1\x6\x10\xFFFF\x1\xD\x1\xFFFF\x1\xE\x3"+
				"\xFFFF\x1\xC\x13\xFFFF\x1\x5\x28\xFFFF\x1\x8\x2\xFFFF\x1\xB\x2\xFFFF"+
				"\x1\x7\x1\xA",
				"\x1\x9\x1\xC\x15\xFFFF\x1\xB\x1\x6\x10\xFFFF\x1\xD\x1\xFFFF\x1\xE\x3"+
				"\xFFFF\x1\xC\x13\xFFFF\x1\x5\x28\xFFFF\x1\x8\x2\xFFFF\x1\xB\x2\xFFFF"+
				"\x1\x7\x1\xA",
				"\x1\x20\x1\xFFFF\x2\x20\x1\xFFFF\x4\x20\x1\x21\x4\xFFFF\x1\x20\x4\xFFFF"+
				"\x2\x20\xD\xFFFF\x1\x1F\x27\xFFFF\x1\x1E\x6\xFFFF\x1\x22",
				"\x1\x20\x1\xFFFF\x2\x20\x1\xFFFF\x4\x20\x1\x21\x4\xFFFF\x1\x20\x4\xFFFF"+
				"\x2\x20\xD\xFFFF\x1\x1F\x2E\xFFFF\x1\x22",
				"\x1\x20\x1\xFFFF\x2\x20\x1\xFFFF\x4\x20\x5\xFFFF\x1\x20\x4\xFFFF\x2"+
				"\x20\xD\xFFFF\x1\x1F\x2E\xFFFF\x1\x23",
				"\x1\x20\x1\xFFFF\x2\x20\x1\xFFFF\x4\x20\x5\xFFFF\x1\x20\x4\xFFFF\x2"+
				"\x20\xD\xFFFF\x1\x1F\x2E\xFFFF\x1\x23",
				"\x1\x20\x1\xFFFF\x2\x20\x1\xFFFF\x4\x20\x5\xFFFF\x1\x20\x4\xFFFF\x2"+
				"\x20",
				"\x1\x20\x1\xFFFF\x2\x20\x1\xFFFF\x4\x20\x5\xFFFF\x1\x20\x4\xFFFF\x2"+
				"\x20",
				"\x1\x20\x1\xFFFF\x2\x20\x1\xFFFF\x4\x20\x5\xFFFF\x1\x20\x4\xFFFF\x2"+
				"\x20",
				"\x1\x20\x1\xFFFF\x2\x20\x1\xFFFF\x4\x20\x5\xFFFF\x1\x20\x4\xFFFF\x2"+
				"\x20",
				"\x1\x24\x5\xFFFF\x1\x26\x31\xFFFF\x1\x25\x18\xFFFF\x1\x27",
				"\x1\x9\x1\xC\x15\xFFFF\x1\xB\x11\xFFFF\x1\xD\x1\xFFFF\x1\xE\x3\xFFFF"+
				"\x1\xC\x3C\xFFFF\x1\x8\x2\xFFFF\x1\xB\x2\xFFFF\x1\x7\x1\xA",
				"\x1\x9\x1\xC\x15\xFFFF\x1\xB\x11\xFFFF\x1\xD\x1\xFFFF\x1\xE\x3\xFFFF"+
				"\x1\xC\x3C\xFFFF\x1\x8\x2\xFFFF\x1\xB\x2\xFFFF\x1\x7\x1\xA",
				"\x1\x9\x1\xC\x15\xFFFF\x1\xB\x11\xFFFF\x1\xD\x1\xFFFF\x1\xE\x3\xFFFF"+
				"\x1\xC\x3C\xFFFF\x1\x8\x2\xFFFF\x1\xB\x2\xFFFF\x1\x7\x1\xA",
				"\x1\xC\x15\xFFFF\x1\xB\x11\xFFFF\x1\xD\x1\xFFFF\x1\xE\x3\xFFFF\x1\xC"+
				"\x3F\xFFFF\x1\xB",
				"\x1\x28\x4A\xFFFF\x1\x29",
				"\x1\x9\x1\xC\x15\xFFFF\x1\xB\x1\x6\x10\xFFFF\x1\xD\x1\xFFFF\x1\xE\x3"+
				"\xFFFF\x1\xC\x3C\xFFFF\x1\x8\x2\xFFFF\x1\xB\x2\xFFFF\x1\x7\x1\xA",
				"\x1\x2E\x5\xFFFF\x1\x30\x14\xFFFF\x1\x2D\x1\x2B\x1B\xFFFF\x1\x2F\x5"+
				"\xFFFF\x1\x2C\x1\x2A\x11\xFFFF\x1\x31",
				"\x1\x32\x3E\xFFFF\x1\x34\xB\xFFFF\x1\x33",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x35",
				"\x1\x35",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F",
				"\x1\x1F"
			};

		private static readonly short[] DFA6_eot = DFA.UnpackEncodedString(DFA6_eotS);
		private static readonly short[] DFA6_eof = DFA.UnpackEncodedString(DFA6_eofS);
		private static readonly char[] DFA6_min = DFA.UnpackEncodedStringToUnsignedChars(DFA6_minS);
		private static readonly char[] DFA6_max = DFA.UnpackEncodedStringToUnsignedChars(DFA6_maxS);
		private static readonly short[] DFA6_accept = DFA.UnpackEncodedString(DFA6_acceptS);
		private static readonly short[] DFA6_special = DFA.UnpackEncodedString(DFA6_specialS);
		private static readonly short[][] DFA6_transition;

		static DFA6()
		{
			int numStates = DFA6_transitionS.Length;
			DFA6_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA6_transition[i] = DFA.UnpackEncodedString(DFA6_transitionS[i]);
			}
		}

		public DFA6( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 6;
			this.eot = DFA6_eot;
			this.eof = DFA6_eof;
			this.min = DFA6_min;
			this.max = DFA6_max;
			this.accept = DFA6_accept;
			this.special = DFA6_special;
			this.transition = DFA6_transition;
		}

		public override string Description { get { return "561:1: selector : ( simple_selector -> simple_selector | simple_selector simple_selector -> ^( DESCENDANT_COMBINATOR ( simple_selector )+ ) | simple_selector '>' ( link_selector )* simple_selector -> ^( CHILD_COMBINATOR ( simple_selector )+ ( link_selector )* ) | simple_selector '<' simple_selector -> ^( PARENT_COMBINATOR ( simple_selector )+ ) );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _entry_in_stylesheet2690 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_stylesheet2693 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rule_in_entry2713 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _import_statement_in_entry2718 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selector_in_rule2738 = new BitSet(new ulong[]{0x80000000UL,0x80000000000000UL});
		public static readonly BitSet _119_in_rule2741 = new BitSet(new ulong[]{0x80000000000200UL});
		public static readonly BitSet _selector_in_rule2743 = new BitSet(new ulong[]{0x80000000UL,0x80000000000000UL});
		public static readonly BitSet _119_in_rule2747 = new BitSet(new ulong[]{0x80000000UL,0x80000000000000UL});
		public static readonly BitSet _declaration_blocks_in_rule2750 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simple_selector_in_selector2774 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simple_selector_in_selector2803 = new BitSet(new ulong[]{0x80000000000200UL});
		public static readonly BitSet _simple_selector_in_selector2805 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simple_selector_in_selector2823 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _OP_GT_in_selector2825 = new BitSet(new ulong[]{0x80000100000200UL});
		public static readonly BitSet _link_selector_in_selector2827 = new BitSet(new ulong[]{0x80000100000200UL});
		public static readonly BitSet _simple_selector_in_selector2831 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simple_selector_in_selector2848 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _OP_LT_in_selector2850 = new BitSet(new ulong[]{0x80000000000200UL});
		public static readonly BitSet _simple_selector_in_selector2852 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACKET_in_link_selector2872 = new BitSet(new ulong[]{0x0UL,0x100000UL});
		public static readonly BitSet _ROLE_in_link_selector2874 = new BitSet(new ulong[]{0xC20F680000000000UL});
		public static readonly BitSet _binary_operator_in_link_selector2876 = new BitSet(new ulong[]{0x3000008200UL,0x4000182UL});
		public static readonly BitSet _predicate_primitive_in_link_selector2878 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RBRACKET_in_link_selector2880 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACKET_in_link_selector2896 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _INDEX_in_link_selector2898 = new BitSet(new ulong[]{0x20F400000000000UL});
		public static readonly BitSet _int_operator_in_link_selector2902 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _POSITIVE_INT_in_link_selector2906 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RBRACKET_in_link_selector2908 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _123_in_layer_id_selector2932 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _CSS_IDENT_in_layer_id_selector2936 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IMPORT_in_import_statement2980 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _URL_in_import_statement2982 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _117_in_import_statement2984 = new BitSet(new ulong[]{0x8000UL,0x4000000UL});
		public static readonly BitSet _quoted_in_import_statement2988 = new BitSet(new ulong[]{0x0UL,0x40000000000000UL});
		public static readonly BitSet _118_in_import_statement2990 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _CSS_IDENT_in_import_statement2994 = new BitSet(new ulong[]{0x0UL,0x800000UL});
		public static readonly BitSet _SEMICOLON_in_import_statement2996 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_selector_in_simple_selector3019 = new BitSet(new ulong[]{0x100000102UL,0xE18000000000800UL});
		public static readonly BitSet _class_selector_in_simple_selector3021 = new BitSet(new ulong[]{0x100000102UL,0xC10000000000800UL});
		public static readonly BitSet _zoom_selector_in_simple_selector3024 = new BitSet(new ulong[]{0x100000102UL,0xC10000000000000UL});
		public static readonly BitSet _attribute_selector_in_simple_selector3027 = new BitSet(new ulong[]{0x100000102UL,0xC10000000000000UL});
		public static readonly BitSet _pseudo_class_selector_in_simple_selector3030 = new BitSet(new ulong[]{0x102UL,0xC10000000000000UL});
		public static readonly BitSet _layer_id_selector_in_simple_selector3033 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RANGE_in_zoom_selector3076 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DQUOTED_STRING_in_quoted3101 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SQUOTED_STRING_in_quoted3115 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CSS_IDENT_in_cssident3137 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACKET_in_attribute_selector3156 = new BitSet(new ulong[]{0x3000008200UL,0x4000004000182UL});
		public static readonly BitSet _predicate_in_attribute_selector3159 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RBRACKET_in_attribute_selector3161 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quoted_in_lhs3182 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CSS_IDENT_in_lhs3190 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OSM_TAG_in_lhs3206 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _predicate_ident_in_predicate3227 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quoted_in_predicate3258 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _predicate_primitive_in_predicate3293 = new BitSet(new ulong[]{0xC20F680000000000UL});
		public static readonly BitSet _binary_operator_in_predicate3295 = new BitSet(new ulong[]{0x3000008200UL,0x4000182UL});
		public static readonly BitSet _predicate_primitive_in_predicate3297 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _predicate_ident_in_predicate3313 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _OP_MATCH_in_predicate3315 = new BitSet(new ulong[]{0x8000UL,0x4004000UL});
		public static readonly BitSet _rhs_match_in_predicate3317 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _114_in_predicate3333 = new BitSet(new ulong[]{0x200UL,0x2UL});
		public static readonly BitSet _predicate_ident_in_predicate3335 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _predicate_ident_in_predicate3362 = new BitSet(new ulong[]{0x0UL,0x1000000000000000UL});
		public static readonly BitSet _124_in_predicate3364 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _114_in_predicate3391 = new BitSet(new ulong[]{0x8000UL,0x4000000UL});
		public static readonly BitSet _quoted_in_predicate3393 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quoted_in_predicate3424 = new BitSet(new ulong[]{0x0UL,0x1000000000000000UL});
		public static readonly BitSet _124_in_predicate3426 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CSS_IDENT_in_predicate3459 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _117_in_predicate3461 = new BitSet(new ulong[]{0x8000UL,0x4000000UL});
		public static readonly BitSet _quoted_in_predicate3463 = new BitSet(new ulong[]{0x0UL,0x40000000000000UL});
		public static readonly BitSet _118_in_predicate3465 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cssident_in_predicate_ident3494 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OSM_TAG_in_predicate_ident3501 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _num_in_predicate_primitive3520 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _predicate_ident_in_predicate_primitive3526 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quoted_in_predicate_primitive3531 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quoted_in_rhs_match3543 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REGEXP_in_rhs_match3550 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _115_in_class_selector3648 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _cssident_in_class_selector3651 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _121_in_class_selector3668 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _cssident_in_class_selector3671 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _122_in_pseudo_class_selector3700 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _cssident_in_pseudo_class_selector3702 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _116_in_pseudo_class_selector3723 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _cssident_in_pseudo_class_selector3725 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_pseudo_class_selector3742 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _cssident_in_pseudo_class_selector3744 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CSS_IDENT_in_type_selector3779 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_MUL_in_type_selector3797 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declaration_block_in_declaration_blocks3822 = new BitSet(new ulong[]{0x80000002UL});
		public static readonly BitSet _declaration_block_in_declaration_blocks3825 = new BitSet(new ulong[]{0x80000002UL});
		public static readonly BitSet _LBRACE_in_declaration_block3852 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _declarations_in_declaration_block3854 = new BitSet(new ulong[]{0x0UL,0x1000UL});
		public static readonly BitSet _RBRACE_in_declaration_block3856 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_declaration_block3873 = new BitSet(new ulong[]{0x0UL,0x1000UL});
		public static readonly BitSet _RBRACE_in_declaration_block3875 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declaration_in_declarations3906 = new BitSet(new ulong[]{0x2UL,0x800000UL});
		public static readonly BitSet _SEMICOLON_in_declarations3909 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _declaration_in_declarations3911 = new BitSet(new ulong[]{0x2UL,0x800000UL});
		public static readonly BitSet _SEMICOLON_in_declarations3915 = new BitSet(new ulong[]{0x2UL,0x800000UL});
		public static readonly BitSet _declaration_property_in_declaration3933 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_declaration3935 = new BitSet(new ulong[]{0x3208488200UL,0x1040C01F2UL});
		public static readonly BitSet _declaration_value_in_declaration3937 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cssident_in_declaration_property3959 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _single_value_in_declaration_value3971 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _single_value_in_declaration_value3976 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _119_in_declaration_value3979 = new BitSet(new ulong[]{0x3008408200UL,0x1040C01F2UL});
		public static readonly BitSet _single_value_in_declaration_value3981 = new BitSet(new ulong[]{0x2UL,0x80000000000000UL});
		public static readonly BitSet _119_in_declaration_value3984 = new BitSet(new ulong[]{0x3008408200UL,0x1040C01F2UL});
		public static readonly BitSet _single_value_in_declaration_value3986 = new BitSet(new ulong[]{0x2UL,0x80000000000000UL});
		public static readonly BitSet _EVAL_in_declaration_value4002 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _117_in_declaration_value4005 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _expr_in_declaration_value4007 = new BitSet(new ulong[]{0x0UL,0x40000000000000UL});
		public static readonly BitSet _118_in_declaration_value4009 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LIST_in_declaration_value4024 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _117_in_declaration_value4027 = new BitSet(new ulong[]{0x3008408200UL,0x1040C01F2UL});
		public static readonly BitSet _single_value_in_declaration_value4029 = new BitSet(new ulong[]{0x0UL,0xC0000000000000UL});
		public static readonly BitSet _119_in_declaration_value4032 = new BitSet(new ulong[]{0x3008408200UL,0x1040C01F2UL});
		public static readonly BitSet _single_value_in_declaration_value4034 = new BitSet(new ulong[]{0x0UL,0xC0000000000000UL});
		public static readonly BitSet _118_in_declaration_value4038 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LIST_in_declaration_value4054 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _117_in_declaration_value4057 = new BitSet(new ulong[]{0x0UL,0x40000000000000UL});
		public static readonly BitSet _118_in_declaration_value4059 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INT_in_num4080 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEGATIVE_INT_in_num4100 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_FLOAT_in_num4120 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEGATIVE_FLOAT_in_num4138 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INT_in_single_value4163 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEGATIVE_INT_in_single_value4186 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_FLOAT_in_single_value4209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEGATIVE_FLOAT_in_single_value4230 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INCREMENT_in_single_value4252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POINTS_in_single_value4278 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PIXELS_in_single_value4295 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PERCENTAGE_in_single_value4315 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _URL_in_single_value4330 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RGB_in_single_value4345 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _117_in_single_value4347 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _POSITIVE_INT_in_single_value4351 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _119_in_single_value4353 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _POSITIVE_INT_in_single_value4357 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _119_in_single_value4359 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _POSITIVE_INT_in_single_value4363 = new BitSet(new ulong[]{0x0UL,0x40000000000000UL});
		public static readonly BitSet _118_in_single_value4365 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RGBA_in_single_value4408 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _117_in_single_value4410 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _POSITIVE_INT_in_single_value4414 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _119_in_single_value4416 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _POSITIVE_INT_in_single_value4420 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _119_in_single_value4422 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _POSITIVE_INT_in_single_value4426 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _119_in_single_value4428 = new BitSet(new ulong[]{0x3000000000UL,0x180UL});
		public static readonly BitSet _num_in_single_value4432 = new BitSet(new ulong[]{0x0UL,0x40000000000000UL});
		public static readonly BitSet _118_in_single_value4434 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HEXCOLOR_in_single_value4469 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quoted_in_single_value4494 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OSM_TAG_in_single_value4526 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cssident_in_single_value4556 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalExpression_in_expr4577 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_args4588 = new BitSet(new ulong[]{0x2UL,0x80000000000000UL});
		public static readonly BitSet _119_in_args4591 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _expr_in_args4593 = new BitSet(new ulong[]{0x2UL,0x80000000000000UL});
		public static readonly BitSet _booleanAndExpression_in_logicalExpression4622 = new BitSet(new ulong[]{0x1000000000000002UL});
		public static readonly BitSet _OP_OR_in_logicalExpression4646 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _logicalExpression_in_logicalExpression4648 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _equalityExpression_in_booleanAndExpression4741 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _OP_AND_in_booleanAndExpression4765 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _booleanAndExpression_in_booleanAndExpression4767 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression4871 = new BitSet(new ulong[]{0x200400000000002UL});
		public static readonly BitSet _OP_EQ_in_equalityExpression4895 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression4898 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_NEQ_in_equalityExpression4929 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression4931 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _additiveExpression_in_relationalExpression5037 = new BitSet(new ulong[]{0xF000000000002UL});
		public static readonly BitSet _OP_LT_in_relationalExpression5061 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _additiveExpression_in_relationalExpression5063 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_LE_in_relationalExpression5094 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _additiveExpression_in_relationalExpression5096 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_GT_in_relationalExpression5127 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _additiveExpression_in_relationalExpression5129 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_GE_in_relationalExpression5160 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _additiveExpression_in_relationalExpression5162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression5250 = new BitSet(new ulong[]{0x2000000000000002UL,0x100000000000000UL});
		public static readonly BitSet _OP_PLUS_in_additiveExpression5274 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _additiveExpression_in_additiveExpression5277 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _120_in_additiveExpression5308 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _additiveExpression_in_additiveExpression5311 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression5400 = new BitSet(new ulong[]{0xC0000000004002UL});
		public static readonly BitSet _OP_MUL_in_multiplicativeExpression5420 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _multiplicativeExpression_in_multiplicativeExpression5422 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DIV_in_multiplicativeExpression5451 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _multiplicativeExpression_in_multiplicativeExpression5453 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_MOD_in_multiplicativeExpression5482 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _multiplicativeExpression_in_multiplicativeExpression5484 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _114_in_unaryExpression5603 = new BitSet(new ulong[]{0x3000008200UL,0x20000004000182UL});
		public static readonly BitSet _primaryExpression_in_unaryExpression5605 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_unaryExpression5628 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _117_in_primaryExpression5666 = new BitSet(new ulong[]{0x3000008200UL,0x24000004000182UL});
		public static readonly BitSet _expr_in_primaryExpression5668 = new BitSet(new ulong[]{0x0UL,0x40000000000000UL});
		public static readonly BitSet _118_in_primaryExpression5670 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CSS_IDENT_in_primaryExpression5692 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _117_in_primaryExpression5694 = new BitSet(new ulong[]{0x3000008200UL,0x64000004000182UL});
		public static readonly BitSet _args_in_primaryExpression5696 = new BitSet(new ulong[]{0x0UL,0x40000000000000UL});
		public static readonly BitSet _118_in_primaryExpression5699 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_FLOAT_in_primaryExpression5722 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INT_in_primaryExpression5742 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEGATIVE_FLOAT_in_primaryExpression5764 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEGATIVE_INT_in_primaryExpression5784 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quoted_in_primaryExpression5804 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cssident_in_primaryExpression5815 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OSM_TAG_in_primaryExpression5828 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_OR_in_synpred1_MapCSS4641 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_AND_in_synpred2_MapCSS4760 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_EQ_in_synpred3_MapCSS4889 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_NEQ_in_synpred4_MapCSS4924 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_LT_in_synpred5_MapCSS5055 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_LE_in_synpred6_MapCSS5088 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_GT_in_synpred7_MapCSS5121 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_GE_in_synpred8_MapCSS5154 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_PLUS_in_synpred9_MapCSS5269 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _120_in_synpred10_MapCSS5303 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_MUL_in_synpred11_MapCSS5414 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DIV_in_synpred12_MapCSS5445 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_MOD_in_synpred13_MapCSS5476 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _114_in_synpred14_MapCSS5598 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets



}
